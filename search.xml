<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2018读书书单]]></title>
    <url>%2F2018%2F11%2F19%2Fread2018%2F</url>
    <content type="text"><![CDATA[其实今年有读挺多书，但是一直懒得写读书笔记，据不完全统计，以下是今年读过的书： 你一年的8760小时-艾力（励志书偶尔看就可以了） 单恋 - 东野圭吾 彷徨之刃 - 东野圭吾 谁杀了她 - 东野圭吾 没有凶手的暗夜 - 东野圭吾 幻夜 - 东野圭吾（看完这一本书之后就再也不想看东野圭吾的作品了） 幸存者 - 法医秦明（高中最喜欢的厕所读物） 明朝那些事儿 - 当年明月（花了很长时间读完的，觉得挺有趣） 笑场 - 李诞（因为喜欢李诞所以才读的） 黄金时代 - 王小波（三十而立那一章节最有意思） 围城 - 钱钟书（听了围城的大名很多年，终于鼓起勇气读了） 亲密关系 - Christopher Moon（读这本书收获很多，疯狂安利身边的人读） 胡兰成自传：今生今世 - 胡兰成（看锵锵三人行讲到这本书） 龙族(第五部) - 江南（满满都是青春，不知何时才更完） 活着活着就老了 - 冯唐（距离4年再读冯唐作品） 目前手上还有好几本李银河的作品和万历十五年这本书，目测今年读不完了，毕竟距离12月很近了，如果有时间还想重温一下《红楼梦》、《水浒传》和《三国演义》，毕竟看这三本书是十年前的事了，如今再重温肯定会有不一样的收获。]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>2018读书书单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP协议的三次握手和四次分手]]></title>
    <url>%2F2018%2F11%2F08%2Ftcp%2F</url>
    <content type="text"><![CDATA[# 三次握手什么是三次握手 第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后客户端进入SYN_SEND状态，等待服务器的确认。 第二次握手：服务器收到SYN报文段。服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1（Sequence Number + 1），向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。 为什么要进行三次握手为了防止服务器一直等待而浪费资源 假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据，这样会白白浪费server很多资源。 四次分手什么是四次分手 第一次分手：主机1（客户端/服务器）设置Sequence Number和Acknowledgment Number向主机2发送一个FIN报文段，此时主机1进入FIN_WAIT_1状态，这表示主机1没有数据要发送给主机2了。 第二次分手：主机2收到主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number+1；主机1进入FIN_WAIT_2状态，这表示主机2告诉主机1“我同意你的关闭请求”。 第三次分手：主机2向向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_WAIT状态。 第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接，此时主机1等待2MSL（最大报文段生存时间）后依然没有收到回复，则证明Server端已正常关闭，然后主机1也可以关闭连接了。 ❓为什么当客户端进入TIME-WAIT状态的时候必须经过时间计数器设置的时间2MSL后才能进入CLOSED状态？ A: 为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。 他还可以防止已失效的报文段。客户端在发送最后一个ACK之后，再经过经过2MSL，就可以使本链接持续时间内所产生的所有报文段都从网络中消失。从保证在关闭连接后不会有还在网络中滞留的报文段去骚扰服务器。 为什么要进行四次分手TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着， 当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据。 当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的； 当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。 一些说明 Sequence Number：用来标识从TCP发端向TCP收端发送的数据字节流，它表示在这个报文段中的第一个数据字节在数据流中的序号； Acknowledgment Number：32位确认序列号包含发送确认的一端所期望收到的下一个序号，因此确认序号应当是上次已成功收到数据字节序号加1（只有当标志位中的ACK=1时该确认序列号的字段才有效）； TCP Flags：TCP首部中有6个标志比特，主要用于操控TCP的状态机，依次为URG、ACK、PSH、RST、SYN、FIN。 ACK：表示应答域有效，为1时表示应答域有效，反之为0。 SYN：表示同步序号，用来建立连接。 当连接请求时，SYN=1，ACK=0 当连接被响应时，SYN=1，ACK=1 FIN：表示发送端已经大道数据末尾，也就是双方的数据传送完成，没有数据可以传送了，发送FIN标志位的TCP数据包后，连接将被断开。 FIN_WAIT_1：其实FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1状态一般是比较难见到的，而FIN_WAIT_2状态还有时常常可以用netstat看到。（主动方） FIN_WAIT_2：FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你(ACK信息)，稍后再关闭连接。（主动方） LAST_WAIT：它是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。（被动方） TIME_WAIT：表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FINWAIT1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。（主动方） CLOSED：表示连接中断]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>TCP</tag>
        <tag>三次握手</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React理念]]></title>
    <url>%2F2018%2F11%2F08%2Freact%E7%90%86%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[单向数据流 确定UI组件层级 确定state的位置 添加反向数据流 例子：可搜索的产品数据表格实现步骤： 把UI划分出组件层级 定义UI状态的最小表示（即确定有哪些state） 确定state位置 添加反向数据流 1. 把UI划分出组件层级层级结构 FilterableProductTable：包含整个例子 SearchBar：接受所有的用户输入 ProductTable：根据用户输入过滤并展示数据集合 ProductCategoryRow：展示每个分类的标题 ProductRow：用行来展示每个产品 效果图 2. 定义UI状态的最小表示找出应用程序的绝对最小表示并计算你所需要的其他任何请求。 考虑State时遵循的三个问题： 它是通过props从父级传来的吗？如果是，它可能不是state。 它随着时间推移不变吗？如果是，它可能不是state。 你能根据组件中任何其他的state或props把它计算出来吗？如果是，它不是state。 该实例应用中所有数据： 原产品列表 用户输入的搜索文本 复选框的值 产品的筛选列表 原产品列表被作为props传入，所以它不是 state。搜索文本和复选框似乎是 state，因为它们随时间改变并且不能由其他任何值计算出来。最后，产品的筛选列表不是state，因为它可以通过将原始产品列表与搜索文本和复选框的值组合计算出来。 最后，我们的state有： 用户输入的搜索文本 复选框的值 3. 确定State位置确定你的State 应该放在哪个组件中，遵循的4个问题如下： 确定每一个需要这个state来渲染的组件 找到一个公共所有者组件(一个在层级上高于所有其他需要这个state的组件的组件) 这个公共所有者组件或另一个层级更高的组件应该拥有这个state 如果你没有找到可以拥有这个state的组件，创建一个仅用来保存状态的组件并把它加入比这个公共所有者组件层级更高的地方 最后，我们State的位置有： ProductTable需要根据state过滤产品列表，SearchBar需要展示搜索文本和复选框状态 公共所有者组件是FilterableProductTable 筛选文本和复选框的值应该放在FilterableProductTable 4. 添加反向数据流也就是向props中添加事件处理程序，触发父组件传递给子组件用于修改父组件中state的回调函数，注意这里每个组件只能直接修改存储在自己内部的state，调用this.setState()函数进行修改，并不能直接修改自己上级或者下级组件的state：当要修改自己上级组件的state时，可以调用上级组件通过props传递给自己的回调函数；对下级组件的数据传递通过props。 源码可搜索的产品数据表格实例完整源码戳这里]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[防火墙]]></title>
    <url>%2F2018%2F11%2F08%2Ffirewall%2F</url>
    <content type="text"><![CDATA[定义防火墙是位于两个（或多个）网络之间执行访问控制的软件和硬件系统，它根据访问控制规则对进出网络的数据流进行过滤。 防火墙可以作为不同网络或网络安全域之间信息的出入口，能根据单位或部门的安全策略控制出入网络的信息流，且本身具有较强的抗攻击能力。它是提供信息安全服务、实现网络和信息安全的重要基础设施。 实质上，防火墙就是一种能够限制网络访问的设备或软件。 许多网络设备均含有简单的防火墙功能，比如路由器、调制解调器、IP交换机等。 软件防火墙有：Windows系统和Linux系统均自带有软件防火墙，可以通过策略（或规则）定制相关的功能。 功能 防火墙是在两个网络之间执行控制策略的系统（包括硬件和软件），目的是不被非法用户侵入。它遵循的是一种允许或禁止业务来往的网络通信安全机制，也就是提供可控的过滤网络通信，只允许授权的通信。因此，对数据和访问的控制、对网络活动的记录，是防火墙的基本功能。 过滤进、出网络的数据 检查所有进、出数据的细节，并根据事先定义好的策略允许或禁止这些数据进行通信。 管理进、出网络的访问行为 通过将动态的、应用层的过滤能力和认证相结合，实现www、FTP和Telnet等广泛的服务的安全支持。 封堵某些禁止的业务 禁止存在安全脆弱性的服务进出网络。 记录通过防火墙的信息内容和活动 审计并记录所有通过防火墙的重要信息，以发现试图的入侵行为。 对网络攻击的检测和告警 分类根据防火墙在网络协议栈中的过滤层次不同，把防火墙分为三种： 包过滤防火墙 电路级网关防火墙 应用级网关防火墙 一般来说，大多数市面上销售的防火墙产品包含以下一种或多种防火墙结构： 静态包过滤 动态包过滤 电路级网关 应用级网关 状态检查包过滤 切换代理 空气隙（物理隔离） 一般来说，防火墙工作于OSI模型的层次越高，其检查数据包中的信息就越多，因此防火墙所消耗的处理器工作周期就越长；防火墙检查的数据包越靠近OSI模型的上层，该防火墙结构所能提供的安全保护等级就越高，因为在高层上能够获得更多的信息用于安全决策。 网络地址转换NATNAT(Network Address Translation)技术可以： 实现多个内部网络地址共用一个IP（包过滤网关类防火墙的一项基本功能） 隐藏内部网络的拓扑结构（提高了网络的安全性） 静态包过滤防火墙静态包过滤防火墙可以采用路由器上的过滤模块来实现。 工作原理静态包过滤防火墙采用一组过滤规则对每个数据包进行检查，然后根据检查结果确定转发/丢弃该数据包。 工作流程 接收每个到达的数据包 对数据包采用过滤规则，对数据包的IP头和传输字段内容进行检查。如果数据包的头信息与一组规则匹配，则根据该规则确定是转发还是丢弃该数据包。 如果没有规则与数据包头信息匹配，则对数据包施加默认规则 默认规则可以丢弃或接收所有数据包。默认丢弃数据包规则更严格，而默认接收数据包规则更开放。 通常，防火墙首先默认丢弃所有数据包，然后再逐个执行过滤规则，以加强对数据包的过滤 决定接收/拒绝一个数据包，取决于对数据包中IP头和协议头等特定域的检查和判定。这些特定域包括： 源地址 目的地址 应用或协议 源端口号 目的端口号 在每个包过滤器上，安全管理员要根据企业的安全策略定义一个表单，这个表单也被称为访问控制规则库 该规则库包含许多规则，用来指示防火墙应该拒绝/接收该数据包。在向前转发某个数据包之前，包过滤器防火墙将IP头和TCP头中的特定域与规则库中的规则逐条进行比较。防火墙按照一定的次序扫描规则库，直到包过滤器发现一个特定域满足包过滤规则的特定要求时，才对数据包做出接收/丢弃的判决。如果包过滤器没有发现有一个规则与该数据包匹配，那么它将对其施加一个默认规则。该默认规则在防火墙的规则库中有明确的定义，一般情况下防火墙将不满足规则的数据包丢弃。 优点 对网络性能的影响较小 成本较低 缺点 安全性较低 缺少状态感知能力 容易遭受IP欺骗攻击 创建访问控制规则比较困难 动态包过滤防火墙 动态包过滤器是最普遍使用的一种防火墙技术，既具有很高的安全性，又具有完全的透明性 动态包过滤防火墙可以根据网络当前的状态检查数据包，即根据当前所交换的信息动态调整过滤规则表 优点 安全性能优于静态包过滤防火墙 具有状态感知能力 成本较低 缺点 仅工作于网络层，因而仅检查IP头和TCP头 安全性较低。因为没有对数据包的净荷部分进行过滤 （净荷（Payload）是指异步转移模式（ATM）信元中除去信头的纯信息部分） 容易遭受伪装IP地址欺骗攻击 创建访问控制规则比较困难 无法抵抗半开连接攻击 TCP半开连接是指发送了TCP连接请求，等待对方应答的状态，此时连接并没有完全建立起来，双方还无法进行通信交互的状态，此时就称为半连接。 一个完整的TCP连接需要经过三次握手才能完成，这里把三次握手之前的连接都称之为半连接。 电路级网关 电路级网关又称线路级网关，作用就好像一台中继计算机，用来在两个连接之间来回地复制数据，也可以记录或缓存数据。 当有来自Internet的请求进入时，它作为服务器接收外来请求，并转发请求；当有内部主机请求访问Internet时，它则担当代理服务器的角色。 电路级网关监视两主机建立连接时的握手信息，如Syn、Ask和序列号等是否合乎逻辑，判定该会话请求是否合法。在有效会话连接建立后，电路级网关仅复制、传递数据，而不进行过滤。 工作原理 电路级网关在转发一个数据包之前，首先将数据包的IP头和TCP头与由管理员定义的规则表相比较，以确定防火墙是将数据包丢弃/通过。 在可信客户机与不可信主机之间进行TCP握手通信时，当SYN标志、ACK标志及序列号符合逻辑时，电路级网关才会判定该会话是合法的。 如果会话合法，包过滤器就开始对规则进行逐条扫描，直到发现其中一条规则与数据包中的有关信息一致。 如果包过滤器没有发现适合该数据包的规则，它就会对该数据包施加一条默认规则。在防火墙的规则表中，这条默认规则通常是指示防火墙将不满足规则的数据包丢弃。 优点 对网络性能有一定程度的影响。性能比包过滤防火墙差，但是比应用代理防火墙好。 切断两外部网络到防火墙后的服务器直接连接。 比包过滤防火墙具有更高的安全性。 缺点 无法抵御应用层的攻击 仅提供一定程度的安全性 当增加新的内部程序或资源时，往往需要对许多电路级网关的代码进行修改 应用级网关 应用级网关只能对特定服务的数据流进行过滤 应用级网关必须为特定的应用级服务编写特定的代理程序。这些程序被称为“服务代理”，在网关内部分别扮演客户机代理和服务器代理的角色。 工作原理 与电路级网关一样，应用级网关截获进出网络的数据包，运行代理程序来回复制和传递通过网关的信息，起着代理服务器的作用。它可以避免内网中的可信服务器或客户机与外网中某个不可信的主机之间的直接连接。 应用级网关与电路级网关上所运行的应用代理程序有两个重要区别： 代理是针对应用的 代理对整个数据包进行检查，因此能在OSI模型的应用层上对数据包进行过滤 应用级网关必须针对每个特定的服务运行一个特定的代理，它只能对特定服务所生成的数据包进行传递和过滤。 如果一个网络使用了应用级网关防火墙，而且网关上没有运行某些应用服务的代理，那么这些服务的数据包都不能进出网络。 应用级网关防火墙上运行的代理程序对数据包进行逐个检查和过滤，而不是简单地复制数据让数据包轻易地通过网关。 特定的应用代理检查通过网关的每个数据包，在OSI模型的应用层上验证数据包内容。这些代理可以对应用协议中的特定信息或命令进行过滤，这就是所谓的关键词过滤或命令字过滤 当前应用级网关防火墙所采用的技术叫做强应用代理。强应用代理不是对用户的整个数据包进行复制，而是在防火墙内部创建一个全新的空数据包。强应用代理将那些可接收的命令或数据，从防火墙外部的原始数据报中复制到防火墙内新创建的数据包中。然后强应用代理将此新数据包发送给防火墙后面受保护的服务器。 优点 在已有的安全模型中安全性较高 具有强大的认证功能 具有超强的日志功能 应用级网关防火墙的规则配置比较简单 缺点 缺乏透明性 缺乏对新应用、新协议的支持 灵活性很差，对每一种应用都需要设置一个代理 配置繁琐，增加了管理员的工作量。（因为各种应用代理的设置方法不同） 性能不高，有可能成为网络的瓶颈 状态检测防火墙状态检测技术采用的是一种基于连接的状态检测机制，将属于同一个连接的所有包作为一个数据流的整体看待，构成连接状态表，通过规则表与状态表的共同配合，对表中的各个连接状态因素加以识别。 工作原理 先进的状态检测防火墙读取、分析和利用了全面的网络通信信息和状态： 通信信息：即所有七层协议的当前信息 通信状态：即以前的通信信息 应用状态：即其他相关应用的信息 操作信息：即在数据包中能执行逻辑运算或数学运算的信息 状态检测模块能够理解并学习各种协议和应用，以支持各种最新的应用，它比代理服务器支持的协议和应用要多得多；并且，它能从应用程序中收集状态信息并存入状态表中，以供其他应用或协议做检测策略。 状态检测技术采用强大的面向对象的方法，基于通信信息、通信状态、应用状态等多方面因素，利用灵活的表达形式，结合安全规则、应用识别知识、状态关联信息及通信数据，构造更复杂的、更灵活的、满足用户特定安全要求的策略规则。 状态检查防火墙将动态包过滤、电路级网关和应用级网关等各项技术结合在一起。由于状态检测防火墙可以在OSI模型的所有七个层次上进行过滤，所以在理论上来说具有很高的安全性。 但是目前大多数状态检测防火墙只工作于网络层，而且只作为动态包过滤器对进出网络的数据进行过滤。 优点 具有动态包过滤的所有优点，同时具有更高安全性（因为增加了状态检测机制，所以能够抵御利用协议细节进行的攻击） 没有打破客户/服务器模型 提供集成的动态（状态）包过滤功能 当以动态包过滤模式运行时，其速度很快 缺点 仅能提供较低水平的安全性 当状态检测防火墙作为动态包过滤防火墙使用时，无法防范应用层攻击（因为过滤的层析仅限于网络层和传输层，无法对应用层内容进行检测） 切换代理工作原理切换代理(Cutoff Proxy)实际上是动态（状态）包过滤器和一个电路级代理的结合。切换代理首先起电路级代理（工作于会话层）的作用，以验证RFC建议的三步握手，然后再切换到动态包过滤（工作于网络层）的工作模式下。 优点 与传统电路级网关相比，它对网络性能造成的影响要小 降低了IP欺骗的风险（对三步握手进行了验证） 缺点 具有较低安全性 难于创建规则 其安全性不及传统电路级网关]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>防火墙</tag>
        <tag>Firewall</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac迅雷瘦身]]></title>
    <url>%2F2018%2F10%2F10%2Fmac-thunder%2F</url>
    <content type="text"><![CDATA[打开应用程序目录，选中迅雷App，在辅助菜单中点击显示包内容进入其内部 删除Contents &gt; Bundles目录 进入Contents &gt; PlugIns目录，删除插件，建议删除的插件有： advertising(广告) featuredpage(主页) feedback(反馈) iOSThunder(手机迅雷) myvip(会员中心) softmanager(软件管家) viprenew(会员开通) viptips(会员提示) xlbrowser(内置浏览器) xlplayer(迅雷影音) 如果不需要开机自启动迅雷，可以删除Contents &gt; Library &gt; LoginItems目录]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[持续集成服务Travis CI了解下]]></title>
    <url>%2F2018%2F09%2F26%2Ftravis-ci%2F</url>
    <content type="text"><![CDATA[什么是持续集成持续集成(Continuous Integration,简称CI)，指的是在一个项目中，任何人对代码库的任何改动都会触发CI服务器自动对项目进行构建，自动运行测试，甚至自动部署到测试环境。优点是随时发现问题，随时修复。 如何为Github上托管的开源项目用Travis CI进行持续集成什么是Travis CITravis CI是一个在线的、分布式的持续集成服务，用来构建及测试在Github托管的代码。 使用Travis CI先决环境要开始使用Travis CI，需要满足以下条件： 拥有一个Github账户 拥有Github上托管的项目的所有者权限 开始使用Travis CI 访问官方网站https://travis-ci.org/，使用github账户登入Travis CI 接受Travis CI的授权。 单击绿色激活按钮，然后选择要与Travis CI一起使用的项目 到Github仓库获取TOKEN。打开setting-&gt;Developer settings-&gt;Personal access tokens 到Travis添加TOKEN。setting-&gt;Environment Variables 添加.travis.yml文件到存储库以告知Travis CI要执行的操作。 12345678910language: "node_js"node_js: - "node"install: - "npm install gitbook -g" - "npm install -g gitbook-cli"script: - "gitbook build"after_success: - "sh build.sh" 添加build.sh脚本文件到存储库 123456789101112131415161718192021#!/bin/bashset -o errexit -o nounsetTRAVIS_BRANCH=masterif [ "$TRAVIS_BRANCH" != "master" ]then echo "This commit was made against the $TRAVIS_BRANCH and not the master! No deploy!" exit 0 fi rev=$(git rev-parse --short HEAD) cd _book git init git config user.name "Travis" git config user.email "evey_wong@163.com" git remote add upstream https://evey-huang:$TOKEN@github.com/yznu-cn/yznu-cn.github.io.git git fetch upstream git reset upstream/master #echo "custom domain" &gt; CNAME git add -A git commit -m "rebuild pages at $&#123;rev&#125;" git push -q upstream HEAD:master 将.travis.yml和build.sh文件添加到git，commit和push以触发Travis CI构建 到https://travis-ci.org/查看构建是否通过 Travis CI实战这次之所以接触到Travis CI是因为学长组织了一个开源学习小组，要我帮忙做这个事。没接触之前觉得好难啊，接触之后觉得也没这么难，还挺好玩的。想看代码戳这里]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>Travis CI</tag>
        <tag>持续集成服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[State&生命周期]]></title>
    <url>%2F2018%2F09%2F26%2Fstate%2F</url>
    <content type="text"><![CDATA[State 局部状态state：一个功能只适用于类定义组件； 构造函数(constructor)是唯一能够初始化this.state的地方； 应当使用setState()更新局部状态，而不是直接更改this.state的值； this.props和this.state可能是异步更新，不能用来计算this.state的下一个值，应该用setState回调函数的方式传入参数； 当你调用setState()时，React将你提供的对象合并到当前状态，更新其中一个(state.name)属性时，会将该属性合并到this.state对象中； 自顶向下或单向数据流，任何状态始终由某些特定组件所有，并且从该状态导出的任何数据或UI只能影响树中的下方组件。 生命周期 挂载：组件加载到DOM中 卸载：生成的DOM被移除 生命周期钩子：componentWillUnmount()挂载前，componentDidUnmount()挂载后 123456789101112131415161718192021222324252627282930313233343536373839class Clock extends React.Component &#123; constructor(props) &#123; /*构造函数*/ super(props); /*传递props*/ this.state = &#123;date: new Date()&#125;;/*唯一能够初始化this.state的地方*/ &#125; componentDidMount() &#123; /*挂载，react元素加载到DOM中*/ this.timerID = setInterval( () =&gt; this.tick(), 1000 ); &#125; componentWillUnmount() &#123; /*卸载，react元素即将从DOM中删除*/ clearInterval(this.timerID); &#125; tick() &#123; this.setState(&#123; /*使用this.setState()来更新组件局部状态*/ date: new Date() &#125;); /* setState回调函数的方式传入参数更改state的值 this.setState((prevState, props) =&gt; (&#123; date: prevState.date + 1 &#125;)); */ &#125; render() &#123; return ( &lt;div&gt; /*自顶向下或单向数据流，结果为先渲染h1然后是h2，最后是h3*/ &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;Hello, Evey!&lt;/h2&gt; &lt;h3&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;&lt;/h3&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;Clock /&gt;, document.getElementById(&apos;root&apos;))]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>state</tag>
        <tag>生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSX]]></title>
    <url>%2F2018%2F09%2F26%2Fjsx%2F</url>
    <content type="text"><![CDATA[什么是JSX本质上来讲，JSX 只是为 React.createElement(component, props, …children) 方法提供的语法糖。比如： 1&lt;MyButton color=&quot;blue&quot; shadowSize=&#123;2&#125;&gt; Click Me &lt;/MyButton&gt; 编译为： 1React.createElement( MyButton, &#123;color: &apos;blue&apos;, shadowSize: 2&#125;, &apos;Click Me&apos; ) 使用JSX需要注意 JSX中使用JavaScript表达式用大括号包起来。 1&lt;h1&gt;Hello, &#123;formatName(user)&#125;!&lt;/h1&gt; if或者for语句里使用JSX，将它赋值给变量，当作参数传入，作为返回值都可以。 123456function getGreeting(user) &#123; if(user) &#123; return &lt;h1&gt;Hello, &#123;formatName(user)&#125;!&lt;/h1&gt;; /*当参传入数*/ &#125; return &lt;h1&gt;Hello, Stanger.&lt;/h1&gt; /*作为返回值*/ &#125; JSX换行和缩进时，推荐在JSX代码的外面扩上一个小括号，这样可以防止分号自动插入的bug。 123const element = ( getGreeting(user) ); JSX标签是闭合式的。 1const element = &lt;img src=&#123;user.avatarUrl&#125; /&gt;; React DOM 使用camelCase小驼峰命名来定义属性的名称 1function formatName(user) &#123; return user.firstName + &apos;&apos; + user.lastName; &#125; 所有的内容在渲染之前都被转换成来字符串，有效地防止XSS攻击。 1const title = response.potentiallyMaliciousInput; const element = &lt;h1&gt;&#123;title&#125;&lt;/h1&gt;; /*这样写是安全的*/ 注释语法：{/**/} 1const element = &lt;img src=&#123;user.avatarUrl&#125; /&gt;; /*注释*/ JSX标签名不能为一个表达式，可以先赋值给一个变量 12345678/*wrong*/ function Story(props) &#123; return &lt;components[props.storyType] story=&#123;props.story&#125; /&gt;; &#125; /*correct*/ function Story(props) &#123; const SpecificStory = components[props.storyType]; return &lt;SpecificStory story=&#123;props.story&#125; /&gt;; &#125; 没有给属性传值，它默认为true 123/*两者等效*/ &lt;TextBox autocomplete /&gt; &lt;TextBox autocomplete=&#123;true&#125; /&gt;]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>JSX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组件&props]]></title>
    <url>%2F2018%2F09%2F26%2Fprops%2F</url>
    <content type="text"><![CDATA[组件可以将UI切分成一些独立的、可复用的部件，从概念上看就像是函数，它可以接收任意的参数（称之为“props”），并返回一个需要在页面上展示的React元素。由于props具有只读性，因此所有的React组件必须像纯函数那样使用它们的props。 组件定义定义组件有两种方法，分别为函数定义和类定义，例： 12345678910/*函数定义组件*/function Welcome(props) &#123; /*自定义组件，组件名首字母大写*/ return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125;/*类定义组件*/class Welcome extends React.Component &#123; render() &#123; return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125; 组合组件组件可以在它的输出中引入其他组件，React应用中按钮、表单、对话框、整个屏幕的内容等这些通常都被表示为组件，组件的返回值只能有一个根元素。 12345678function App() &#123; return ( &lt;div&gt; /*组件的返回值只能有一个根元素*/ &lt;Welcome name=&quot;Sara&quot; /&gt; &lt;Welcome name=&quot;Cahal&quot; /&gt; &lt;/div&gt; );&#125; 提取组件组件由于嵌套太多会变得难以被修改，可复用的部分也难以被复用。在大型应用中，构建可复用组件是很有必要的。例： 12345678910111213141516171819202122232425262728293031323334/*提取前*/function Comment(props) &#123; return ( &lt;div className=&quot;Comment&quot;&gt; &lt;div className=&quot;UserInfo&quot;&gt; &lt;img className=&quot;Avatar&quot; src=&#123;props.author.avatarUrl&#125; alt=&#123;props.author.name&#125; /&gt; &lt;/div&gt; &lt;/div&gt; );&#125;/*提取后*/function Avatar(props) &#123; return ( &lt;img className=&quot;Avatar&quot; src=&#123;props.user.avatarUrl&#125; alt=&#123;props.user.name&#125; /&gt; );&#125;function UserInfo(props) &#123; return ( &lt;div className=&quot;UserInfo&quot;&gt; &lt;Avatar user=&#123;props.user&#125; /&gt; &lt;/div&gt; );&#125;function Comment(props) &#123; return ( &lt;div className=&quot;Comment&quot;&gt; &lt;UserInfo user=&#123;props.author&#125; /&gt; &lt;/div&gt; );&#125;]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>props</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组合VS继承]]></title>
    <url>%2F2018%2F09%2F26%2Fcombination%2F</url>
    <content type="text"><![CDATA[组合VS继承 React具有强大的组合模型，建议使用组合而不是继承来复用组件之间的代码 包含关系。一些组件（比如Sidebar或Dialog）不能提前知道它们的子组件是什么，所以建议这些组件使用children属性将子元素直接传递到输出 特殊实例。有时我们认为组件是其他组件的特殊实例，这也是通过组合来实现的，通过配置属性（props）用较特殊的组件来渲染较通用的组件 12345678910111213141516171819202122function FancyBorder(props) &#123; console.log(props) return ( &lt;div className=&#123;&apos;FancyBorder FancyBorder-&apos; + props.color&#125;&gt; &#123;props.children&#125; &lt;/div&gt; );&#125;function Dialog(props) &#123; return ( &lt;FancyBorder color=&quot;blue&quot;&gt; &lt;h1 className=&quot;Dialog-title&quot;&gt;&#123;props.title&#125;&lt;/h1&gt; &lt;p className=&quot;Dialog-message&quot;&gt;&#123;props.message&#125;&lt;/p&gt; &lt;/FancyBorder&gt; );&#125; function WelcomeDialog() &#123; return ( &lt;Dialog title=&quot;welcome&quot; message=&quot;Thank you for visiting our spacecraft!&quot; /&gt; );&#125;]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>组合</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[状态提升]]></title>
    <url>%2F2018%2F09%2F26%2Fstatus%2F</url>
    <content type="text"><![CDATA[状态提升在构建真实应用的时候，随着业务的复杂度的提升，我们编写的组件的结构层次也会越来越复杂，处理的数据也会越来越庞大，同一份数据有时会由多个不同的组件渲染，因此在多个不同的组件内部有可能会修改同一份数据，这样便出现了数据共享问题。解决这个问题的初步方式之一就是状态提升。 状态提升过程状态提升的做法就是将在某个界面位置相邻组件的数据统一交由公共的父组件管理，由父组件负责接收数据，将其变为内部的state，然后将公共部分的state数据以props的方式传入到子组件，然后子组件通过暴露updateState的回调接口给父组件，在子组件内部需要更新新的数据时，只要通过回调接口把数据传回给父组件，之后父组件再接收新数据同时调用setState()方法来更新数据状态，这样其他子组件也会随之而更新。这样便将状态的维护统一由一个组件来维护，将可能的bug完全封装在一个组件内部。如果将来界面变动，要求添加新的子组件时，只要按这个做法继续添加就可以，不会影响到其它组件。 例如： 下列示例中，定义了两个会修改温度temperature的输入框组件，把这个temperature属性交给Calculator组件来维护，然后在Calculator里将temperature属性分别以props的形式向下传递给输入组件，同时暴露一个回调，在内部以事件的形式，在用户输入后将新的数据回传给Calculator修改，Calculator在获得新数据后使用setState()方法来进行刷新，这样两个输入框数据就可以同步更新。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687const scaleNames = &#123; c: &apos;Celsius&apos;, f: &apos;Fahrenheit&apos;&#125;; // 摄氏度和华氏度互相转换函数function toCelsius(fahrenheit) &#123; return (fahrenheit - 32) * 5 / 9;&#125; function toFahrenheit(celsius) &#123; return (celsius * 9 / 5) + 32;&#125; // 当temperature输入不合法时，这个函数就会返回空字符串function tryConvert(temperature, convert) &#123; const input = parseFloat(temperature); if(Number.isNaN(input)) &#123; return &apos;&apos;; &#125; const output = convert(input); const rounded = Math.round(output * 1000) / 1000; return rounded.toString();&#125; function BoilingVerdict(props) &#123; if(props.celsius &gt;= 100) &#123; return &lt;p&gt;The water would boil&lt;/p&gt;; &#125; return &lt;p&gt;The water would not boil&lt;/p&gt;;&#125; class TemperatureInput extends React.Component &#123; constructor(props) &#123; super(props); this.handleChange = this.handleChange.bind(this); &#125; handleChange(e) &#123; this.props.onTemperatureChange(e.target.value); &#125; render() &#123; const temperature = this.props.temperature; const scale = this.props.scale; return ( &lt;fieldset&gt; &lt;legend&gt;Enter temperature in &#123;scaleNames[scale]&#125;&lt;/legend&gt; &lt;input value=&#123;temperature&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;/fieldset&gt; ); &#125;&#125;class Calculator extends React.Component &#123; constructor(props) &#123; super(props); this.handleCelsiusChange = this.handleCelsiusChange.bind(this); this.handleFahrenheitChange = this.handleFahrenheitChange.bind(this); this.state = &#123;temperature: &apos;&apos;, scale: &apos;c&apos;&#125;; &#125; handleCelsiusChange(temperature) &#123; this.setState(&#123;scale: &apos;c&apos;, temperature&#125;); &#125; handleFahrenheitChange(temperature) &#123; this.setState(&#123;scale: &apos;f&apos;, temperature&#125;); &#125; render() &#123; const scale = this.state.scale; const temperature = this.state.temperature; const celsius = scale === &apos;f&apos; ? tryConvert(temperature, toCelsius) : temperature; const fahrenheit = scale === &apos;c&apos; ? tryConvert(temperature, toFahrenheit) : temperature; return ( &lt;div&gt; &lt;TemperatureInput scale=&quot;c&quot; temperature=&#123;celsius&#125; onTemperatureChange=&#123;this.handleCelsiusChange&#125;/&gt; &lt;TemperatureInput scale=&quot;f&quot; temperature=&#123;fahrenheit&#125; onTemperatureChange=&#123;this.handleFahrenheitChange&#125;/&gt; &lt;BoilingVerdict celsius=&#123;parseFloat(celsius)&#125;/&gt; &lt;/div&gt; ); &#125;&#125; ReactDOM.render( &lt;Calculator /&gt;, document.getElementById(&apos;root&apos;));]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>props</tag>
        <tag>status</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[元素渲染]]></title>
    <url>%2F2018%2F09%2F26%2Felement%2F</url>
    <content type="text"><![CDATA[元素是构成React应用的最小单位。元素构成组件，组件又构成应用。元素用来描述你在屏幕上看到的内容，比如： 1const element = &lt;h1&gt;Hello world!&lt;/h1&gt;; 渲染元素到DOM在此div中的所有内容都将由React DOM来管理，称之为“根”DOM节点。一个用React构建的应用程序通常只有一个根DOM节点。 1&lt;div id=&quot;root&quot;&gt;&lt;/div&gt; 要将React元素渲染到根DOM节点中，我们通过把它们都传递给 ReactDOM.render() 的方法来将其渲染到页面上： 12345const element = &lt;h1&gt;Hello World!&lt;/h1&gt;ReactDOM.render( element, document.getElementId(&apos;root&apos;)); 更新元素渲染React元素都是不可变的，即当元素被创建后，是无法改变其内容或属性的。根据目前所学知识，更新界面的唯一办法是创建一个新的元素，然后将它传入ReactDOM.render()方法。例： 1234567891011121314function tick() &#123; const element = ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;new Date().toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); ReactDOM.render( element, document.getElementById(&apos;example&apos;) );&#125;// React DOM 首先会比较元素内容先后的不同，而在渲染过程中只会更新改变了的部分。即这里只会更新时间setInterval(tick, 1000); /*通过setInterval方法每秒钟调用一次ReactDOM.render()，以此更新元素渲染*/ 按需更新元素渲染React DOM 首先会比较元素内容先后的不同，而在渲染过程中只会更新改变了的部分。 在上个例子中感觉每秒根节点所有内容都重新渲染更新一次，其实只有时间在变化，h1文本不变。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>element</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条件渲染]]></title>
    <url>%2F2018%2F09%2F26%2Fif%2F</url>
    <content type="text"><![CDATA[使用JavaScript操作符if或条件运算符来创建表示当前状态的元素，然后让React根据它们来更新UI； 元素变量。可以声明一个变量来储存元素，渲染组件得其中一部分元素； 与运算符&amp;&amp;。通过用花括号包裹代码在JSX中嵌入任何表达式，也包括JavaScript的逻辑与&amp;&amp;，JavaScript中，true&amp;&amp;expression总是返回expression，而false&amp;&amp;expression总是返回false，如果条件是true，&amp;&amp;右侧的元素就会被渲染，如果是false，React会忽略并跳过它； 三目运算符。condition ？ true ： false； 阻止组件渲染：让render方法返回null即可阻止组件渲染 12345678910111213141516171819202122232425262728293031323334353637function WarningBanner(props) &#123; if(!props.warn) &#123; return null; /*返回null，阻止组件渲染*/ &#125; const a = &lt;a&gt;超链接&lt;/a&gt;;/*存储元素到变量*/ if(props.warn == &quot;a&quot;) &#123; /*if条件句渲染*/ return a; &#125; return ( &lt;div className=&quot;warning&quot;&gt; Warning! &lt;/div&gt; );&#125;class Page extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;showWarning: true&#125; this.handleToggleClick = this.handleToggleClick.bind(this); &#125; handleToggleClick() &#123; this.setState(prevState =&gt; (&#123; showWarning: !prevState.showWarning &#125;)); &#125; render() &#123; return ( &lt;div&gt; &lt;WarningBanner warn=&#123;this.state.showWarning&#125; /&gt; &lt;button onClick=&#123;this.handleToggleClick&#125;&gt; &#123;this.state.showWarning ? &apos;Hide&apos; : &apos;Show&apos;&#125; /*三目运算符渲染*/ &lt;/button&gt; &#123;this.props.warn == &quot;b&quot; &amp;&amp; &lt;a&gt;b超链接&lt;/a&gt;&#125; /*与运算符&amp;&amp;渲染*/ &lt;/div&gt; ); &#125;&#125;]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>if</tag>
        <tag>与运算符</tag>
        <tag>三目运算符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件处理]]></title>
    <url>%2F2018%2F09%2F26%2Ffunction%2F</url>
    <content type="text"><![CDATA[React事件绑定属性的命名采用驼峰式写法； 1234/*传统HTML*/&lt;button onclick=&quot;activeLasers()&quot;&gt;Activate Lasers&lt;/button&gt;/*React*/&lt;button onClick=&quot;activeLasers()&quot;&gt;Activate Lasers&lt;/button&gt; 如果采用JSX的语法你需要传入一个函数作为事件处理函数，而不是一个字符串（DOM元素写法）； 在React中不能使用返回false的方式阻止默认行为，必须明确使用e.preventDefault(); 12345678910111213141516/*传统HTML*/&lt;a href=&quot;#&quot; onclick=&quot;console.log(&apos;The link was clicked.&apos;); return false&quot;&gt;Click me&lt;/a&gt; /*React*/function ActionLink() &#123; function handleClick(e) &#123; e.preventDefault(); console.log(&apos;The link was clicked.&apos;); &#125; return ( &lt;a href=&quot;#&quot; onClick=&#123;handleClick&#125;&gt; Click me &lt;/a&gt; );&#125; 类的方法默认不会绑定this，如果没有在方法后面添加”()”，则要构造函数中为这个方法绑定this； 123456789101112131415161718192021class Toggle extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;isToggleOn: true&#125;; this.handleClick = this.handleClick.bind(this);/*构造函数中绑定this*/ &#125; handleClick() &#123; this.setState(prevState =&gt; (&#123; isToggleOn: !prevState.isToggleOn &#125;)); &#125; render() &#123; return ( &lt;button onClick=&#123;this.handleClick&#125;&gt; &#123;this.state.isToggleOn ? &apos;ON&apos; : &apos;OFF&apos;&#125; &lt;/button&gt; ); &#125;&#125; 向事件处理程序传递参数。参数 e 作为 React 事件对象将会被作为第二个参数进行传递。通过箭头函数的方式，事件对象必须显式的进行传递，但是通过 bind 的方式，事件对象以及更多的参数将会被隐式的进行传递。 123456/*参数 e 作为 React 事件对象将会被作为第二个参数进行传递*/&lt;button onClick=&#123;(e) =&gt; this.deleteRow(id, e)&#125;&gt;Delete Row&lt;/button&gt; /*通过 bind 方式向监听函数传参*/&lt;button onClick=&#123;this.deleteRow.bind(this, id)&#125;&gt;Delete Row&lt;/button&gt;]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[列表&Keys]]></title>
    <url>%2F2018%2F09%2F22%2Freact-%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[渲染多个组件可以通过花括号{}在JSX内构建一个元素集合 12345678const numbers = [1, 2, 3, 4, 5];const listItems = numbers.map((numbers) =&gt; &lt;li&gt;&#123;numbers&#125;&lt;/li&gt;);ReactDOM.render( &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt;, document.getElementById(&apos;root&apos;)); 上面的例子通过使用map()方法遍历numbers数组，对数组中的每个元素返回&lt;li&gt;标签，最后得到一个数组listItems，然后把整个listItems插入到ul元素中，最后渲染进根DOM。 基础列表组件通常需要渲染一个列表到组件中。当创建一个元素时，必须包括一个特殊的key属性。key是唯一的标识，可以使用数据里面的id作为key，key应该绑定在循环的组件上而不是DOM元素上，key应该在数组的上下文中被指定。 12345678910111213141516function NumberList(props) &#123; const numbers = props.numbers; const listItems = numbers.map((number) =&gt; &lt;li key=&#123;number.toString()&#125;&gt;&#123;number&#125;&lt;/li&gt; ); return ( &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt; );&#125; const numbers = [1, 2, 3, 4, 5];ReactDOM.render( &lt;NumberList numbers=&#123;numbers&#125;/&gt;, document.getElementById(&apos;root&apos;));]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>列表</tag>
        <tag>keys</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速开始]]></title>
    <url>%2F2018%2F09%2F22%2Freact-%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B%2F</url>
    <content type="text"><![CDATA[前提 Node&gt;=6 搭建环境 全局安装create-react-app命令行工具 1$ npm install -g create-react-app 创建第一个React工程 1$ create-react-app my-app 启动项目 12$ cd my-app$ npm start 简单的React例子ReactDOM.render 是 React 的最基本方法，用于将模板转为 HTML 语言，并插入指定的 DOM 节点。该例子中将一个h1标题插入root节点，最终渲染出一个“Hello World”标题。 12345678import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;; ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById(&apos;root&apos;));]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeMirror——在线代码编辑器]]></title>
    <url>%2F2018%2F09%2F12%2Fcodemirror%2F</url>
    <content type="text"><![CDATA[学React正开心，同事突然叫我帮忙弄一下这个编辑器，什么鬼？？我没搞过，whatever，撸起袖子开造就对了。 什么是CodeMirror github戳这里 官方文档戳这里 其他自行google 使用CodeMirror的一个例子先执行下列命令 123456$ npm install -g create-react-app$ create-react-app editor$ cd editor/$ cd src/$ rm -rf *$ touch index.js 给index.js添加以下内容： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import React from 'react';import ReactDOM from 'react-dom';import IceContainer from '@icedesign/container';import &#123; UnControlled as CodeMirror &#125; from 'react-codemirror2';import &#123; Grid &#125; from '@icedesign/base';import 'codemirror/lib/codemirror.css';import 'codemirror/theme/icecoder.css'; // 主题import 'codemirror/mode/shell/shell.js'; // 代码高亮require('codemirror/mode/javascript/javascript');const &#123; Row, Col &#125; = Grid;const codeString = `npm run dev`;class CustomCodemirror extends React.Component &#123; static displayName = 'CustomCodemirror'; static propTypes = &#123;&#125;; static defaultProps = &#123;&#125;; constructor(props) &#123; super(props); this.state = &#123; value: codeString, &#125;; &#125; onChange = (editor, data, value) =&gt; &#123; console.log(&#123; data, value &#125;); this.setState(&#123; value, &#125;); &#125;; renderCodeMirror = () =&gt; &#123; const options = &#123; mode: 'shell', lineNumbers: true, tabSize: '2', theme: "icecoder", &#125;; return ( &lt;CodeMirror value=&#123;this.state.value&#125; options=&#123;options&#125; onChange=&#123;this.onChange&#125; /&gt; ); &#125;; render() &#123; return ( &lt;IceContainer&gt; &lt;Row wrap&gt; &lt;Col l="12" xxs="24"&gt; &#123;this.renderCodeMirror()&#125; &lt;/Col&gt; &lt;/Row&gt; &lt;/IceContainer&gt; ); &#125;&#125;ReactDOM.render( &lt;CustomCodemirror /&gt;, document.getElementById('root')); 然后再执行以下命令： 12$ npm install @icedesign/base @icedesign/container codemirror react-codemirror2$ npm start 查看效果： 查看全部代码 具体使用 更改主题 设置编译器编程语言 折叠代码 智能提示 括号匹配 绑定Vim 显示行号 全屏模式 更改主题CodeMirror内置50+种主题，可以戳这里预览 1234import 'codemirror/theme/icecoder.css';options = &#123; theme: "icecoder",&#125;; 设置编译器编程语言CodeMirror支持很多种编程语言，想知道具体有哪些，可以戳这里 1234import 'codemirror/mode/shell/shell.js'; // 设置语言关键词高亮options = &#123; mode: 'shell',&#125;; 折叠代码仅支持JavaScript、HTML、Markdown和Python，预览戳这里 1234567891011import 'codemirror/addon/fold/foldcode.js';import 'codemirror/addon/fold/foldgutter.js';import 'codemirror/addon/fold/brace-fold.js';import 'codemirror/addon/fold/comment-fold.js';import 'codemirror/addon/fold/foldgutter.css';options = &#123; lineWrapping:true, foldGutter: true, gutters:["CodeMirror-linenumbers", "CodeMirror-foldgutter"],&#125;; 智能提示效果预览戳这里 1234567import 'codemirror/addon/hint/show-hint.js';import 'codemirror/addon/hint/anyword-hint.js';import 'codemirror/addon/hint/show-hint.css';options = &#123; extraKeys:&#123;"Ctrl-Space":"autocomplete"&#125;,&#125;; 括号匹配效果预览戳这里 12345import 'codemirror/addon/edit/matchbrackets.js';options = &#123; matchBrackets:true,&#125;; 绑定Vim效果预览戳这里 123options = &#123; keyMap:"vim",&#125;; 显示行号123options = &#123; lineNumbers:true,&#125;; 全屏模式效果预览戳这里 123456import 'codemirror/addon/display/fullscreen.js';import 'codemirror/addon/display/fullscreen.css';options = &#123; fullScreen:true,&#125;; 其他更多用法戳这里]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>codeMirror</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS之object-fit]]></title>
    <url>%2F2018%2F09%2F12%2Fobject-fit%2F</url>
    <content type="text"><![CDATA[CSS属性object-fit指定替换元素的内容应该如何适应到其使用的高度和宽度确定的框。 HTML1234567&lt;div class="box"&gt; &lt;img src="UNADJUSTEDNONRAW_thumb_2d9.jpg" alt="" class="fill"&gt; &lt;img src="UNADJUSTEDNONRAW_thumb_2d9.jpg" alt="contain" class="contain"&gt; &lt;img src="UNADJUSTEDNONRAW_thumb_2d9.jpg" alt="cover" class="cover"&gt; &lt;img src="UNADJUSTEDNONRAW_thumb_2d9.jpg" alt="none" class="none"&gt; &lt;img src="UNADJUSTEDNONRAW_thumb_2d9.jpg" alt="scale-down" class="scale-down"&gt;&lt;/div&gt; CSS1234567891011121314151617181920212223.box &#123; display: flex; justify-content: center;&#125;img &#123; width: 200px; height: 200px; background-color: #cd0000; margin: 30px;&#125;.fill &#123; object-fit: fill;&#125;.contain &#123; object-fit: contain;&#125;.none &#123; object-fit: none;&#125;.scale-down &#123; object-fit: scale-down;&#125; 效果图 fill被替换的内容大小可以填充元素的内容框。整个对象将完全填充此框。如果对象的高宽比不匹配其框的宽高比，那么该对象将被拉伸以适应。 contain被替换的内容将被缩放，以在填充元素的内容框时保持其宽高比。整个对象在填充盒子的同时保留其长宽比，因此如果宽高比与框的宽高比不匹配，该对象将被添加“黑边”。 cover被替换的内容大小保持其宽高比，同时填充元素的整个内容框。如果对象的宽高比与盒子的宽高比不匹配，该对象将被裁剪以适应。 none被替换的内容尺寸不会被改变。 scale-down内容的尺寸就像是指定咯none或contain，取决于哪一个将导致更小的对象尺寸。 浏览器兼容 IE全家不兼容 Chrome29+兼容 Safari7.1+IOS8+兼容]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>object-fit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从0开始搭建一个React项目]]></title>
    <url>%2F2018%2F09%2F10%2Freact1%2F</url>
    <content type="text"><![CDATA[从0开始搭建一个React项目React是什么？React 是一个采用声明式，高效而且灵活的用来构建用户界面的框架。 使用create-react-app快速构建React开发环境1234$ npm install -g create-react-app$ create-react-app my-app$ cd my-app/$ npm start 启动页面]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5隐藏video控件的下载按钮]]></title>
    <url>%2F2018%2F09%2F07%2Fhtml5-video%2F</url>
    <content type="text"><![CDATA[今天需要给官网添加视频，添加完之后发现不需要下载按钮，所以需要隐藏掉，踩了点坑这里记录一下。 正确示范 nodownload 设置是否去除去除下载按钮nodownload 1&lt;video src="video.mp4" controls controlslist="nodownload"&gt;&lt;/video&gt; 参考地址 错误示范（敲重点！没用！！没用！！！）css方法12345678910video &#123; width: 100%; &amp;::-webkit-media-controls &#123; overflow: hidden !important; &#125; &amp;::-webkit-media-controls-enclosure &#123; width: calc(100% + 15px); margin-left: auto; &#125;&#125;]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>video</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS中的尺寸单位]]></title>
    <url>%2F2018%2F08%2F30%2Fcss-unit%2F</url>
    <content type="text"><![CDATA[CSS中的尺寸单位整理一下日常会用到的css尺寸/长度单位。 概览绝对单位 px:：Pixel 像素 pt：Points 磅 相对单位 %：百分比 rem：Root element meter 根据根文档（body/html）字体计算尺寸 vh：View height 可视范围高度 vw：View width 可视范围宽度 运算 calc：calculate 四则运算 详细绝对单位 px-Pixel像素：像素px相对于设备显示器屏幕分辨率而言。 123p &#123; font-size: 14px&#125; pt-Point 磅：3pt = 4px 123p &#123; font-size: 10pt&#125; 相对单位 %百分比：相对于父元素宽度 1234567891011121314&lt;body&gt; &lt;div class="parent"&gt; &lt;div class="children"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;style&gt;.parent &#123; width: 100px&#125;.children &#123; width: 50% // children的宽度为50px&#125;&lt;/style&gt; em-Element meter：根据文档计算尺寸 相对于当前文档对象内文本的字体尺寸而言，若未指定字体大小则继承自上级元素，以此类推，直至body，若body未指定则为浏览器默认大小。 12345678910111213&lt;body&gt; &lt;div class="element"&gt;&lt;/div&gt;&lt;/body&gt;&lt;style&gt;.body &#123; font-size: 14px&#125;.element &#123; font-size: 16px width: 2em // 2em === 32px&#125;&lt;/style&gt; rem-Root element meter：根据根文档（body/html）字体计算尺寸 相对于根文档对象（body/html）内文本的字体尺寸而言，若未指定字体大小则继承为浏览器默认字体大小。 12345678910111213&lt;body&gt; &lt;div class="element"&gt;&lt;/div&gt;&lt;/body&gt;&lt;style&gt;.body &#123; font-size: 14px&#125;.element &#123; font-size: 16px width: 2em // 2em === 28px&#125;&lt;/style&gt; vh-View heigh/vw-View width：可视范围 相对于可视范围的高度和宽度，可视范围被均分为100单位的vh/vw；可视范围是指屏幕可见范围，不是父元素的，百分比是相对于包含它的最近的父元素的高度和宽度。 假设设备可视范围为高度900px，宽度750px，则1vh = 900px/100 = 9px, 1vw = 750px/100 = 7.5px 12345678910111213141516171819&lt;body&gt; &lt;h1&gt;article title&lt;/h1&gt; &lt;div class="element"&gt;&lt;/div&gt; &lt;div class="full-height"&gt;&lt;/div&gt;&lt;/body&gt;&lt;style&gt;.element &#123; width: 500vw; height: 80vh; // 如果屏幕高度为1000px，则该元素高度为800px，vw同理&#125;.full-height &#123; height: 100vh; // 轻易实现了与屏幕同等高度的元素&#125;h1 &#123; width: 100vw; // 设置一个和屏幕同宽的标题，标题的字体大小就会自动根据浏览器的宽度进行缩放，以达到字体和viewport大小同步的效果&#125;&lt;/style&gt; 运算 calc-calculate：四则运算 用于动态计算长度值。 calc运算规则： 需要注意的是，运算符前后都需要保留一个空格； 任何长度值都可以使用calc()函数进行计算； calc()函数支持 “+”, “-“, “*”, “/“ 运算； calc()函数使用标准的数学运算优先级规则； 12345678910&lt;body&gt; &lt;div class="calc"&gt;&lt;/div&gt;&lt;/body&gt;&lt;style&gt;.calc &#123; width: calc(100%-50px); // 宽度为100%-50px&#125;&lt;/style&gt;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>px</tag>
        <tag>pt</tag>
        <tag>rem</tag>
        <tag>vh</tag>
        <tag>vw</tag>
        <tag>calc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo配置动态背景]]></title>
    <url>%2F2018%2F08%2F29%2Fhexo-canvas%2F</url>
    <content type="text"><![CDATA[修改Next主题配置文件_config.yml12# Canvas-nestcanvas_next: true]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>动态背景</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next主题添加站内搜索]]></title>
    <url>%2F2018%2F08%2F29%2Fhexo-next%2F</url>
    <content type="text"><![CDATA[背景随着文章的增多，标签和归档已经不能满足要求了，想要快速查找文章需要一个搜索功能。Next主题支持集成Swiftype、微搜索、Local Search和Algolia，我选择的是Hexo提供的Local Search，原理是通过hexo-generator-search插件在本地生成一个search.xml文件，搜索时从这个文件中根据关键字检索出相应的链接。 安装安装hexo-generator-searchdb插件 1npm install hexo-generator-searchdb --save 修改配置文件修改站点配置文件_config.yml123456# searchsearch: path: search.xml field: post format: html limit: 10000 修改Next主题配置文件_config.yml123# Local searchlocal_search: enable: true]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo]]></title>
    <url>%2F2018%2F08%2F29%2Fhexo1%2F</url>
    <content type="text"><![CDATA[Hexo是一个快速、简洁且高效的博客框架，拥有以下特点： 超快生成速度 支持Markdown所有功能 一键部署 提供丰富的插件 安装前提 Node.js Git 安装Hexo1$ npm install -g hexo-cli 建站12345678# 新建一个网站$ hexo init blog# 进入博客文件夹$ cd blog# 安装依赖$ npm install# 启动服务器$ hexo server 其他指令123456# 部署网站$ hexo deploy 等于$ hexo d# 生成静态文件$ hexo generate 等于 $ hexo g# 新建文章$ hexo new title]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端开发工程师笔试题]]></title>
    <url>%2F2018%2F08%2F21%2F%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%AC%94%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1.标签上title和alt属性的区别是什么？ 含义不同 alt属性在无法加载显示图片时代替文字，title属性则是为设置该属性的元素提供建议性的信息 在浏览器中表现不同 在FireFox和IE8中，当鼠标经过图片时title的值会显示，而alt的值不会显示，只有在IE6中，当鼠标经过图片时title和alt的值都会显示。 网站SEO优化不同 搜索引擎对图片意思的判断主要靠alt属性，所以在图片alt属性中以简要文字说明，同时包含关键词，也是页面优化的一部分。 2.relative、absolute、static、fixed的作用，相对谁定位？ static是默认值，任意position:static的元素不会被特殊的定位。 fixed是固定定位，元素会相对于视窗（body）来定位，这意味着即便页面滚动，它还是会停留在相同的位置，top、right、bottom、left属性都可以用。 relative是相对定位，相对于父元素来定位，不脱离文档流 absolute是绝对定位，相对于最近的positioned祖先元素定位，如果绝对定位的元素没有positioned祖先元素则它相对于body元素定位，并且它会随着页面滚动而移动。 positioned元素是指position值不是static的元素 3.请画出css盒模型。 4.请写一个数组去重的方法。方法1——SetES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 Set本身是一个构造函数，用来生成Set数据结构，Array.from方法可以将Set结构转为数组 在Set内部两个NaN是相等的，两个对象是总不相等的 12345function unique(arr)&#123; return Array.from(new Set(arr));&#125;var arr = [1, 1, 2, 3, null, null, NaN, NaN];console.log(unique(arr)); // [1, 2, 3, null, NaN] 方法2——forEach在forEach中两个NaN不相等 1234567891011function unique(arr)&#123; var newArr = []; arr.forEach(function(item)&#123; if(newArr.indexOf(item) === -1)&#123; newArr.push(item); &#125; &#125;); return newArr;&#125;var arr = [1, 1, 2, 3, null, null, NaN, NaN];console.log(unique(arr)); // [1, 2, 3, null, NaN, NaN] 5.请写一个方法，将URL中的查询字符串解析成一个字典对象。代码1234567891011121314151617function getQueryObject(url) &#123; url = url == null ? window.location.href : url; var search = url.substring(url.lastIndexOf("?") + 1); var obj = &#123;&#125;; var reg = /([^?&amp;=]+)=([^?&amp;=]*)/g; search.replace(reg, function (rs, $1, $2) &#123; var name = decodeURIComponent($1); var val = decodeURIComponent($2); val = String(val); obj[name] = val; return rs; &#125;); return obj;&#125;var url = "http://www.cnblogs.com/leee/p/4456840.html?name=1&amp;dd=ddd**";console.log(getQueryObject(url)); 结果1234[object Object] &#123; dd: "ddd**", name: "1"&#125; 6.一个页面从输入URL到页面加载完的过程中都发生了什么事情？ 用户输入URL地址 浏览器解析URL解析出主机名 浏览器将主机名换成服务器IP地址（浏览器先查找本地DNS缓存列表，没有的话再向浏览器默认的DNS服务器发送查询请求，同时缓存） 浏览器将端口号从URL中解析出来 浏览器建立一条与目标Web服务器的TCP连接（三次握手） 浏览器向服务器发送一条HTTP请求报文 服务器向浏览器返回一条HTTP响应报文 关闭连接，浏览器解析文档 如果文档中有资源，重复6、7、8直至资源全部加载完毕 7.请简述页面渲染的过程。 处理HTML标记并构建DOM树 处理CSS标记并构建CSS DOM树 将DOM与CSS DOM合并成一个渲染树 根据渲染来布局，以计算每个节点的几何信息 将各个节点绘制到屏幕上 9.判断一个字符串中出现次数最多的 字符，并统计这个次数。12345678910111213141516171819202122var str = "abcabcaaa";maxnum(str);function maxnum(str)&#123; var json = &#123;&#125;; for(var i=0;i&lt;str.length;i++)&#123; if(!json[str.charAt(i)])&#123; json[str.charAt(i)] = 1; &#125;else&#123; json[str.charAt(i)]++; &#125; console.log(json); &#125; var max = 0; var Index = ''; for(var i in json)&#123; if(json[i]&gt;max)&#123; max = json[i]; Index = i; &#125; &#125; console.log(max + Index); &#125; 10.请问web前端开发，如何提高页面性能优化？11.请简述你所了解到的web攻击技术。]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>js</tag>
        <tag>html</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据类型]]></title>
    <url>%2F2018%2F08%2F21%2Ftype-of-date%2F</url>
    <content type="text"><![CDATA[基础类型包括：Undefine、Null、Boolean、Number、String，引用类型包括：Object、Array、Function。当一个变量值为引用类型时，直接赋值其他变量传递的是引用。同样的，引用的数据在某个地方改变了值会影响所欲调用这个变量的地方。 Undefine和Null声明一个变量没有赋值，直接访问当前变量可以得到undefine 12let x;console.log(x); // -&gt; undefine 访问一个对象上不存在的key也会取到undefine 12let a = &#123;&#125;;console.log(a.b); // -&gt; undefine null表示空值。它不同于undefine，它是有值的只不过是一个空值，而undefine是未定义的临时兜底的缺省值。 Number、Boolean和StringJavaScript中带引号的均为字符串，可以是单引号也可以是双引号。JavaScript没有int、float和double之分。 1234console.log(typeof 10); // -&gt; numberconsole.log(typeof '10'); // -&gt; stringconsole.log(typeof true); // -&gt; booleanconsole.log(typeof "true"); // -&gt; string Array数组类型、栈结构、有序数组。每个item可以是任意类型的值。 123456789101112131415// 字符串数组['string','aaa']// 对象和字符串混合数组[&#123; aa: 'aaa', bb: 'bbb',&#125;,'string']// 函数数组[() =&gt; &#123; return '这是一个函数'&#125;, () =&gt; &#123; return '这是一个函数'&#125;] 如果需要取得特定需要的值，直接获取（比如获取第一个数据）： 1array[0] 数据是有序的，遍历数组需要使用流程控制语句for等。为了方便，array内置了一些数组常用操作方法可以简化常用操作，比如 forEach()：把数组每个元素丢到一个处理function里面，相当于for循环 every()：所有数组元素处理后全部return true，那么就return true，类似&amp;&amp; some()：只要有一个数组处理后return true，那么就return true，类似|| filter()：将处理时return true的数组元素拿出来组成一个新数组 map()：对每个数组元素进行处理，并组成一个新数组 reduce()：像一个累加器一样，把数组元素全部加起来（从左向右） 12345678910111213let list = [];list.push('aa');list.push('bb');// for循环for(let i=0;i&lt;list.length;i++) &#123; console.log(list[i]);&#125;// forEach循环list.forEach((val, i) =&gt; &#123; console.log(val, i);&#125;) Object对象类型，无序，需要指定key等信息关联值。 12345678910111213let obj = &#123; name: 'string 字符串', home: &#123; province: '山东' &#125;&#125;;obj.age = 18;console.log(obj.name.province);let key = 'age';console.log(obj[key], obj['age']);delete obj.name; 如果不确定key的值（变量）可以使用如下方法调用： 12let key = 'age';obj[key]; // -&gt; 18 Function函数类型，用来创建一个函数，通常会返回一个数据。 1234function fun(a, b) &#123; return a + b;&#125;fun(1, 2); // -&gt; 3 函数是一个可执行的小程序，根据参数处理一些逻辑并返回一段新的数据，在JavaScript中使用非常多，为此ES6新增了箭头函数语法，用来简化函数书写。箭头函数有个重要特点，就是自动绑定了当前的作用域。 1234567let add = function(a, b) &#123; return a + b;&#125;// 等同于let add = (a, b) =&gt; &#123; return a + b&#125; 类型转换类型转换可以通过调用类型的类进行转换，比如将变量a转换成Number类型： 12let a = '10';a = Number(a); 转换Number类型123let a = '12.33'; // stringconsole.log(parseInt(a)); // -&gt; 12 // numberconsole.log(parseFloat(a)); // -&gt; 12.33 number 转换String类型12let a = 12.33; // numberconsole.log(a.toString()); // -&gt; '12.33' string Object转JSON字符串12345678910// JSON转Objectlet obj = &#123; a: 'aa', b: 'bb'&#125;;console.log(JSON.stringify(obj)); // -&gt; '&#123;"a":"aa","b": "bb"&#125;'// Object转JSONlet objStr = '&#123;"a":"aa","b":"bb"&#125;';console.log(JSON.parse(objStr)); // -&gt; &#123;"a":"aa","b": "bb"&#125; 转换Boolean类型1234567console.log(!!'a'); // -&gt; trueconsole.log(!!''); // -&gt; false 空字符串console.log(!!0); // -&gt; false 数字0console.log(!!10); // -&gt; trueconsole.log(!!null); // -&gt; falseconsole.log(!!undefine); // -&gt; falseconsole.log(!![].length); // -&gt; false]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>undefine</tag>
        <tag>boolean</tag>
        <tag>number</tag>
        <tag>string</tag>
        <tag>object</tag>
        <tag>array</tag>
        <tag>function</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript字符串反转]]></title>
    <url>%2F2018%2F08%2F21%2Freverse%2F</url>
    <content type="text"><![CDATA[首先思路： 遍历字符串并将字母链接到新字符串 过程： 第一次迭代，str.length-1 === 5-1 ===o 第二次迭代，4-1 === ol 第三次迭代，3-1 === oll 第四次迭代，2-1 === olle 第五次迭代，1-1 === olleh 方法一思路：使用一个for循环给原字符串做一个递减遍历，然后将遍历的字符串重新合并成一个新字符串 12345678function reverse(str)&#123; var rtnStr = ''; for(var i = str.length-1; i&gt;=0;i--)&#123; rtnStr +=str[i]; &#125; return rtnStr;&#125;reverseString("hello"); // =&gt;olleh 方法二思路：使用递归实现字符串反向 substr()方法返回字符串中从指定位置开始到指定长度的子字符串 charAt()方法返回字符串中指定位置的字符。字符串中的字符从左向右索引，第一个字符的索引值为0 过程：第一次递归 reverseString(“ello”)+’h’ reverseString(“llo”)+’e’ reverseString(“lo”)+’l’ reverseString(“o”)+’l’ reverseString(“”)+’o’ 第二次递归 reverseString(“”)+’o’=’o’ reverseString(“o”)+’l’=’o’+’l’ reverseString(“lo”)+’l’=’o’+’l’+’l’ reverseString(“llo”)+’e’=’o’+’l’+’l’+e reverseString(“ello”)+’h’=’o’+’l’+’l’+’e’+’h’ 12345678function reverseString (str) &#123; if (str === "") &#123; return ""; &#125; else &#123; return reverseString(str.substr(1)) + str.charAt(0); &#125;&#125;reverseString("hello"); // =&gt;olleh 改良版 123function reverseString(str) &#123; return (str === '') ? '' : reverseString(str.substr(1)) + str.charAt(0); &#125;reverseString("hello"); // =&gt;olleh 方法三原理： split()方法将一个字符串对象的每个字符拆出来，并且将每个字符串当成数组的每个元素 reverse()方法用来改变数组，将数组中的元素倒个序排列，第一个数组元素变成最后一个，最后一个变成第一个 join()方法将数组中的所有元素边接成一个字符串 过程： split()将字符串拆分，返回一个新数组[‘h’, ‘e’, ‘l’, ‘l’, ‘o’] reverse()将原数组顺序翻转，返回新数组[‘o’, ‘l’, ‘l’, ‘e’, ‘h’] join()将数组的每个元素连接在一起，组合成新字符串，返回一个新的字符串“olleh” 1234function reverseString(str) &#123; return str.split("").reverse().join(""); &#125;reverseString("hello"); // =&gt; olleh]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>reverse</tag>
        <tag>字符串反转</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue项目使用npm出现的问题]]></title>
    <url>%2F2018%2F08%2F21%2Fvue-npm%2F</url>
    <content type="text"><![CDATA[现象运行单元测试npm run test出现问题： No parser and no filepath given, using ‘babylon’ the parser now but this will throw an error in the future. Please specify a parser or a filepath so one can be inferred. 解决参考原issues：https://github.com/nuxt/nuxt.js/issues/3400，解决方案为: 1npm install vue-loader@13.7.2 --save-dev]]></content>
      <categories>
        <category>NPM</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求两数最大公约数]]></title>
    <url>%2F2018%2F08%2F21%2FgreatestCommonDivisor%2F</url>
    <content type="text"><![CDATA[方法一 初始除数为2，最大公约数为1 如果a、b两数中其中一个为1或者0，则最大公约数为1 如果a、b两数均大于2，a、b均能整除2，则最大公约数为2；否则最大公约数为1 12345678910111213141516171819function greatestCommonDivisor(a, b)&#123; var divisor = 2, greatestDivisor = 1; //if u pass a -ve number this will not work. fix it dude!! if (a &lt; 2 || b &lt; 2) return 1; while(a &gt;= divisor &amp;&amp; b &gt;= divisor)&#123; if(a %divisor == 0 &amp;&amp; b% divisor ==0)&#123; greatestDivisor = divisor; &#125; divisor++; &#125; return greatestDivisor;&#125;// console.log(greatestCommonDivisor(14, 21)) =&gt; 7 // console.log(greatestCommonDivisor(1, 7)) =&gt; 1 方法二1234567function greatestCommonDivisor(a, b)&#123; if(b == 0) return a; else return greatestCommonDivisor(b, a%b);&#125;// console.log(greatestCommonDivisor(5,7)) =&gt; 1 例如： 求5和7的最大公约数，a=5,b=7 return greatestCommonDivisor(7, 5%7) =&gt; a=7,b=1 return greatestCommonDivisor(7, 7%1) =&gt; a=7,b=0 b==0 return a=1 所以5和7最大公约数为1]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>greatestCommonDivisor</tag>
        <tag>最大公约数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[检查回文数]]></title>
    <url>%2F2018%2F08%2F21%2FPalindrome%2F</url>
    <content type="text"><![CDATA[什么是回文回文数是指一个对称的数，即：将这个数的数字按相反的顺序重新排列后，所得到的书和原来的数一样。 12345678910function isPalindrome(str)&#123; var i, len = str.length; for(i =0; i&lt;len/2; i++)&#123; if (str[i]!== str[len -1 -i]) return false; &#125; return true;&#125;isPalindrome('madam') // =&gt; trueisPalindrome('toyota') // =&gt; false]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>Palindrome</tag>
        <tag>回文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何获得第N个斐波那契数]]></title>
    <url>%2F2018%2F08%2F21%2FFibonacci%2F</url>
    <content type="text"><![CDATA[背景斐波那契数列（意大利语: Successione di Fibonacci）又译费波拿契数列、黄金分割数列。 在数学上，斐波那契数列是以递归的方法来定义： F0=0 F1=1 F2=1 F3=2 Fn=F(n-1)+F(n-2) (n&gt;=2) 用文字来说，就二十斐波那契数列由0和1开始，之后的斐波那契数列由之前的两数相加而得出。首几个斐波那契系数是：0,1,1,2,3,5,8,13,21,34,55,89,144,233.... 解答方法一123456789101112function fibonacci(n)&#123; var fibo = [0, 1]; if (n &lt;= 2) return 1; for (var i = 2; i &lt;=n; i++ )&#123; fibo[i] = fibo[i-1]+fibo[i-2]; &#125; return fibo[n];&#125; // console.log(fibonacci(12)) =&gt; 144 运行时复杂度为O(n) 方法二1234567function fibonacci(n)&#123; if(n&lt;=1) return n; else return fibonacci(n-1) + fibonacci (n-2); &#125;// console.log(fibonacci(12)) =&gt; 144 运行时复杂度O(2^n)]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>Fibonacci</tag>
        <tag>斐波那契</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm@6安全审核]]></title>
    <url>%2F2018%2F08%2F21%2Fnpm%E5%AE%89%E5%85%A8%E5%AE%A1%E6%A0%B8%2F</url>
    <content type="text"><![CDATA[问题描述执行npm i出现以下警告： 这是因为npm升级到@6以后，在项目中更新或者下载新的依赖包控制台会自动运行npm audit对项目依赖包进行安全审核，并生成漏洞报告在控制台中显示。 问题解决 自动更新有安全漏洞的依赖项，修补大部分漏洞 1npm audit fix 手动执行npm audit看目前依赖包还有什么问题 1npm audit 访问提示链接https://www.npmjs.com/advisories/48，里面给出了解决方案 手动更新包 1npm i uglify-js@2.6.0]]></content>
      <categories>
        <category>NPM</category>
      </categories>
      <tags>
        <tag>NPM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS数组之排列组合]]></title>
    <url>%2F2018%2F06%2F28%2FJS%E6%95%B0%E7%BB%84%E4%B9%8B%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%2F</url>
    <content type="text"><![CDATA[两个数组排列组合比如目前有两个数组： a=[1,2,3] b=[3,4,5] 那么数组排列的情况就有3*3=9种，代码： 123456789101112var a=[1,2,3];var b=[4,5,6];var newArr=[];var index=0; // 组合次数for(var i=0;i&lt;a.length;i++)&#123; for(var j=0;j&lt;b.length;j++)&#123; newArr[index]=[a[i]].concat(b[j]); index++; &#125;&#125;console.log (newArr);console.log(index) 输出结果： 123[[1, 4], [1, 5], [1, 6], [2, 4], [2, 5], [2, 6], [3, 4], [3, 5], [3, 6]]9 多个数组排列组合方法一1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071var a=['a1', 'a2', null],var b=['b1','b2', 'b3', 'b4', 'any', null],var c=['c1', 'c2', 'c3', 'c4', 'any', null],var d=['d1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', null];var newArr=[];var index=0;for(var i=0;i&lt;a.length;i++)&#123; // 两两组合ab for(var j=0;j&lt;b.length;j++)&#123; newArr[index]=[a[i]].concat(b[j]); index++; // 三三组合abc for(var k=0;k&lt;c.length;k++)&#123; newArr[index]=[a[i]].concat(b[j], c[k]); index++; // 四组合 for(var m=0;m&lt;d.length;m++)&#123; newArr[index]=[a[i]].concat(b[j],c[k],d[m]); index++; &#125; &#125; // 三三组合abd for(var m=0;m&lt;d.length;m++)&#123; newArr[index]=[a[i]].concat(b[j], d[m]); index++; &#125; &#125; for(var m=0;m&lt;c.length;m++)&#123; // 两两组合ac newArr[index]=[a[i]].concat(c[m]); index++; &#125; for(var n=0;n&lt;d.length;n++)&#123; // 两两组合ad newArr[index]=[a[i]].concat(d[n]); index++; // 三三组合abd for(var m=0;m&lt;b.length;m++)&#123; newArr[index]=[a[i]].concat(b[m], d[n]); index++; &#125; &#125;&#125;for(var x=0;x&lt;b.length;x++) &#123; for(var y=0;y&lt;c.length;y++) &#123; // 两两组合bc newArr[index]=[b[x]].concat(c[y]); index++; // 三三组合bcd for(var i=0;i&lt;d.length;i++)&#123; newArr[index]=[b[x]].concat(c[y], d[i]); index++; &#125; &#125; // 两两组合bd for(var j=0;j&lt;d.length;j++)&#123; newArr[index]=[b[x]].concat(d[j]); index++; &#125;&#125;for(var m=0;m&lt;c.length;m++)&#123; // 两两组合cd for(var n=0;n&lt;d.length;n++)&#123; newArr[index]=[c[m]].concat(d[n]); index++; &#125;&#125;console.log (newArr);console.log(index); 方法二12345678910111213141516171819202122232425262728293031323334353637383940414243444546var a=['a1', 'a2', null],var b=['b1','b2', 'b3', 'b4', 'any', null],var c=['c1', 'c2', 'c3', 'c4', 'any', null],var d=['d1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', null];var temp = [];var addTemp = function(obj) &#123; var arr = []; var i = 0; Object.keys(obj).forEach(function(key, index) &#123; arr.push(obj[key]); if(!obj[key]) &#123; i++; &#125; &#125;); if(arr.length !== i) &#123; temp.push(obj); &#125;&#125;;for(var i = 0, len = a.length; i &lt; len; i++) &#123; addTemp(&#123;a: a[i]&#125;); for(var j = 0,len2 = b.length; j &lt; len2; j++) &#123; addTemp(&#123; a: a[i], b: b[j] &#125;); for(var k = 0,len3 = c.length; k &lt; len3; k++) &#123; addTemp(&#123; a: a[i], b: b[j], c: c[k] &#125;); for(var f = 0,len4 = d.length; f &lt; len4; f++) &#123; addTemp(&#123; a: a[i], b: b[j], c: c[k], d: d[f] &#125;); &#125; &#125; &#125;&#125;console.log(temp.length);]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>排列组合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[e2e端到端测试使用ES6遇到的问题及解决方案]]></title>
    <url>%2F2018%2F06%2F28%2Fe2e%E7%AB%AF%E5%88%B0%E7%AB%AF%E6%B5%8B%E8%AF%95%E4%BD%BF%E7%94%A8ES6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[问题描述： (function (exports, require, module, filename, dirname) { import _Object$is from ‘babel-runtime/core-js/object/is’;、 解决： package.json 在package.json添加”babel-preset-es2015” “babel-preset-es2015”: “^6.9.0”, .babelrc 在文件.babelrc中的”presets”字段添加”es2015” “presets”: [ ​ “es2015” ] 最后 1npm install]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>e2e</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Echarts几种常见图标和自适应]]></title>
    <url>%2F2018%2F06%2F28%2FEcharts%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E5%9B%BE%E6%A0%87%E5%92%8C%E8%87%AA%E9%80%82%E5%BA%94%2F</url>
    <content type="text"><![CDATA[按需引入Echarts组件封装组件 index.vue 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;template&gt; &lt;div ref="chart" class="echarts-container"&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;const echarts = require('echarts/lib/echarts')// 引入环形图require("echarts/lib/chart/pie")// 引入柱状图require("echarts/lib/chart/bar")// 引入提示框和标题组件require('echarts/lib/component/tooltip')require('echarts/lib/component/legend')require('echarts/lib/component/title')// 极坐标系，用于散点图和折线图，每个极坐标系拥有一个角度轴和一个半径轴require("echarts/lib/component/polar")// 直角坐标系内绘图网格require("echarts/lib/component/grid")export default &#123; props: ['options'], name: 'echarts', data() &#123; return &#123; chart: null &#125; &#125;, watch: &#123; options: &#123; handler: function() &#123; this.initChart() &#125;, deep: true &#125; &#125;, mounted() &#123; this.initChart() &#125;, methods: &#123; initChart() &#123; this.$nextTick(() =&gt; &#123; setTimeout(() =&gt; &#123; this.chart = echarts.init(this.$refs.chart) this.chart.setOption(this.options) &#125;, 66) &#125;) &#125;, handlerResize() &#123; window.addEventListener('resize', () =&gt; &#123; this.chart.resize() &#125;, false); &#125; &#125;&#125;&lt;/script&gt;&lt;style lang="scss"&gt; .echarts-container &#123; width: 100%; min-height: 200px; &#125;&lt;/style&gt; 使用Echarts实现饼状图、环形图、柱形图chart.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227&lt;template&gt; &lt;main class="status-container"&gt; &lt;echarts ref="chart1" class="echarts" :options="options1"&gt;&lt;/echarts&gt; &lt;echarts ref="chart2" class="echarts" :options="options2"&gt;&lt;/echarts&gt; &lt;echarts ref="chart3" class="echarts" :options="options3"&gt;&lt;/echarts&gt; &lt;echarts ref="chart4" class="echarts" :options="options4"&gt;&lt;/echarts&gt; &lt;echarts ref="chart5" class="echarts" :options="options5"&gt;&lt;/echarts&gt; &lt;loading ref="loading" /&gt; &lt;/main&gt;&lt;/template&gt;&lt;script&gt;import Echarts from "@/components/Echarts"export default &#123; name: 'status', computed: &#123; options1() &#123; return &#123; title: &#123; text: '饼状图1', x: 'center' &#125;, tooltip: &#123; trigger: 'item', formatter: "&#123;b&#125; : &#123;c&#125;" &#125;, series: [ &#123; type: 'pie', radius: '25%', center: ['50%', '60%'], data: [ &#123;value: 335, name: 'A'&#125;, &#123;value: 1548, name: 'B'&#125;, &#123;value: 135, name: 'C'&#125; ], itemStyle: &#123; emphasis: &#123; shadowBlur: 100, shadowOffsetX: 0, shadowColor: 'rgba(0, 0, 0, 0.5)' &#125; &#125; &#125; ] &#125;; &#125;, options2() &#123; return &#123; title: &#123; text: '饼状图2', x: 'center' &#125;, tooltip: &#123; trigger: 'item', formatter: "&#123;b&#125; : &#123;c&#125;" &#125;, series: [ &#123; type: 'pie', radius: '55%', center: ['50%', '60%'], selectedMode: 'single', data: [ &#123;value: 335, name: 'A'&#125;, &#123;value: 1548, name: 'B'&#125;, &#123;value: 135, name: 'C'&#125; ], itemStyle: &#123; emphasis: &#123; shadowBlur: 100, shadowOffsetX: 0, shadowColor: 'rgba(0, 0, 0, 0.5)' &#125; &#125; &#125; ] &#125;; &#125;, options3() &#123; return &#123; title: &#123; text: '环形图', x: 'center' &#125;, tooltip: &#123; trigger: 'item', formatter: "&#123;b&#125; : &#123;c&#125;" &#125;, series: [ &#123; type: 'pie', radius: ['20%', '30%'], center: ['50%', '60%'], label: &#123; normal: &#123; show: false, position: 'center' &#125;, emphasis: &#123; show: true, textStyle: &#123; fontSize: '24', fontWeight: 'bold' &#125; &#125; &#125;, data: [ &#123;value: 335, name: 'A'&#125;, &#123;value: 1548, name: 'B'&#125;, &#123;value: 135, name: 'C'&#125; ] &#125; ] &#125;; &#125;, options4() &#123; return &#123; title: &#123; text: '堆叠柱状图', x: 'center' &#125;, angleAxis: &#123; show: false, &#125;, radiusAxis: &#123; type: 'category', data: ['周一', '周二', '周三', '周四'], min: -4 &#125;, polar: &#123; &#125;, series: [&#123; type: 'bar', data: [1, 2, 3], coordinateSystem: 'polar', name: 'A', stack: 'a' &#125;, &#123; type: 'bar', data: [1, 2, 3, 4], coordinateSystem: 'polar', name: 'B', stack: 'a' &#125;, &#123; type: 'bar', data: [1, 2, 3, 4], coordinateSystem: 'polar', name: 'C', stack: 'a' &#125;, &#123; type: 'bar', data: [1, 2, 3, 4], coordinateSystem: 'polar', name: 'D', stack: 'a' &#125;] &#125;; &#125;, options5() &#123; return &#123; title: &#123; text: '柱状图', x: 'center' &#125;, tooltip: &#123; trigger: 'axis' &#125;, calculable: true, // 是否显示拖拽用的手柄 xAxis: [ &#123; type: 'category', show: false, data: ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L'] &#125; ], yAxis: [ &#123; type: 'value', show: false &#125; ], series: [ &#123; name: 'A', type: 'bar', data: [10, 76.7, 135.6, 162.2, 32.6, 20.0] &#125;, &#123; name: 'B', type: 'bar', data: [28.7, 70.7, 175.6, 182.2, 48.7, 18.8] &#125; ] &#125;; &#125;, &#125;, mounted() &#123; this.$nextTick(() =&gt; &#123; this.$refs.chart1.handlerResize() this.$refs.chart2.handlerResize() this.$refs.chart3.handlerResize() this.$refs.chart4.handlerResize() this.$refs.chart5.handlerResize() &#125;) &#125;, components: &#123; Echarts &#125;&#125;&lt;/script&gt;&lt;style rel="stylesheet/scss" lang="scss" scoped&gt;.status-container &#123; height: 100%; width: 100%; overflow-x: hidden; overflow-y: scroll; .echarts &#123; float: left; width: 50%; height: 50%; &#125;&#125;&lt;/style&gt;]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>echarts</tag>
        <tag>自适应</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VSCode插件配置]]></title>
    <url>%2F2018%2F06%2F28%2FVSCode%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[常用插件 Beautify - 通过配置.jsbeautifyrc文件可以格式化javascript、json、css、sass和html文件 Code Runner - 支持运行多种语言的代码片段或代码文件（比如C++、java等） ESLint - 代码检查 HTML CSS Support - 对HTML文档的CSS支持 HTML Snippets - H5代码片段及提示 Vue 2 Snippets - Vue2代码片段及提示 Auto Close Tag - 匹配标签，关闭对应标签 Auto Rename Tag - 当修改HTML/XML标签时，会自动修改 与之对应的开始/结束标签 Settings Sync - VSCode设置同步到Gist Document This - 生成JS注释模板 vscode-icon - 让VSCode资源树目录加上图标 Path Intellisense - 路径智能提示 Vetur - 语法高亮、智能感知、Emmet等 VueHelper - Vue代码智能提示（包括Vue、Vue-router、Vuex） VSCode设置如何同步到Gist 安装Settings Sync扩展 打开自己的Github-&gt;Settings-&gt;Developer settings-&gt;Personal access tokens-&gt;Generate new token 填写Token描述 在选择范围中选择gist 创建Token 获取Token（注意保存！！） 第一次上传设置 按下组合键Shift+Alt+U，自动打开Github设置页面，允许你为应用程序生成一个新的令牌，然后回到VSCode在窗口中输入刚才获取的Token，最后单击Enter 这样就自动上传了VSCode的设置，并且扩展程序会在系统消息中提供Gist ID。需要Gist ID才能访问你使用Token上传的数据 GitHub Token: 519f1565671630977425bd204984b1d4b32b145bGitHub Gist: 99f2b0be96b188e3bdd459fc4a9b5d28 上传设置 经过第一次上传设置操作之后，可以按下组合键Shift+Alt+U直接上传，无需再次输入Token 下载设置 按下组合键Shift+Alt+D它会询问你的Github Gist ID，然后按要求输入Token然后单击Enter，输入Gist ID，这样就下载好设置了。 最后妈妈再也不用担心我换电脑/系统VSCode配置不见啦，也不需要再重新设置配置啦，一键搞定配置，省心！ Settings Sync官网操作链接戳这里]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>VSCode</tag>
        <tag>Gist</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端开发工程师面试问题]]></title>
    <url>%2F2018%2F06%2F28%2F%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[JS问题JavaScript原型、原型链 ? 有什么特点？每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去，也就是我们平时所说的原型链的概念。 关系：instance.constructor.prototype = instance._proto_ 特点： JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。 javascript作用链域?全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节。当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找，直至全局函数，这种组织形式就是作用域链。 eval是做什么的？ 它的功能是把对应的字符串解析成JS代码并运行；应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval(‘(‘+ str +’)’); 什么是闭包（closure），为什么要用它？闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域，将函数内部的变量和方法传递到外部。 闭包的特性： 函数内再嵌套函数 内部函数可以引用外层的参数和变量 参数和变量不会被垃圾回收机制回收 js延迟加载的方式有哪些?defer和async、动态创建DOM方式（用得最多）、按需异步载入js AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？Asynchronous Module Definition，异步模块定义，所有的模块将被异步加载，模块加载不影响后面语句运行。所有依赖某些模块的语句均放置在回调函数中。 区别： 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible. CMD 推崇依赖就近，AMD 推崇依赖前置。 es6 Object.is() 与原来的比较操作符“ ===”、“ ==”的区别？两等号判等，会在比较时进行类型转换；三等号判等(判断严格)，比较时不进行隐式类型转换,（类型不同则会返回false）；Object.is 在三等号判等的基础上特别处理了 NaN 、-0 和 +0 ，保证 -0 和 +0 不再相同，但 Object.is(NaN, NaN) 会返回 true，Object.is 应被认为有其特殊的用途，而不能用它认为它比其它的相等对比更宽松或严格。 js中有哪些实现异步的方式 回调函数 事件监听 Promise CSS问题元素竖向的百分比设定是相对于容器的高度吗？ 相对于容器的宽度 margin和padding分别适合什么场景使用？margin是用来隔开元素与元素的间距；padding是用来隔开元素与内容的间隔。 margin用于布局分开元素使元素与元素互不相干； padding用于元素与内容之间的间隔，让内容（文字）与（包裹）元素之间有一段 CSS3有哪些新特性？ 新增各种CSS选择器（: not(.input)：所有 class 不是“input”的节点） 圆角（border-radius:8px） 多列布局（multi-column layout） 阴影和反射（Shadow\Reflect）. 文字特效 （text-shadow、）. 文字渲染 （Text-decoration）. 线性渐变 （gradient） 旋转（transform） 缩放,定位,倾斜,动画,多背景 例如:transform:\scale(0.85,0.90)\ translate(0px,-30px)\ skew(-9deg,0deg)\Animation: HTML问题简述一下你对HTML语义化的理解？ 用正确的标签做正确的事情。 html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析; 即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的; 搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO; 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。 iframe有那些缺点？ iframe会阻塞主页面的Onload事件； 搜索引擎的检索程序无法解读这种页面，不利于SEO; iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。 使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript 动态给iframe添加src属性值，这样可以绕开以上两个问题。]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>js</tag>
        <tag>html</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[详解object.is()与比较操作符“===”和“==”]]></title>
    <url>%2F2018%2F06%2F28%2Fobject%2F</url>
    <content type="text"><![CDATA[==操作在需要的情况下自动进行类型转换，===操作不会执行任何转换。 例如： [10] == 10 // true,自动转换为相同类型 [10] === 10 // false，不会进行类型转换 [] == 0 // true [] === 0 //false ‘ ‘ == false // true ‘ ‘ === false // false 在ES6中，Object.is()类似与 ===，但是在===基础上特别处理了NaN、-0、和+0，保证+0和-0不再相等，但NaN和NaN相等，即Object.is(NaN, NaN)会返回true。 以下情况为true Object.is(undefined, undefined) Object.is(null, null) Object.is(true, true) Object.is(false, false) Object.is(+0, -0) Object.is(NaN, NaN) 两个值是由相同个数的字符按照相同的顺序组成的字符串 两个值指向同一个对象 两个值都是数字并且都是除零和 NaN 外的其它同一个数字]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>Object.is()</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用NAP安装包失败解决办法]]></title>
    <url>%2F2018%2F06%2F28%2F%E4%BD%BF%E7%94%A8NAP%E5%AE%89%E8%A3%85%E5%8C%85%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[方法一：通过config命令12$ npm config set registry https://registry.npm.taobao.org$ npm info underscore 方法二：命令行指定1$ npm --registry https://registry.npm.taobao.org info underscore 方法三：编辑~/.npmrc(推荐)1$ registry = https://registry.npm.taobao.org]]></content>
      <categories>
        <category>NPM</category>
      </categories>
      <tags>
        <tag>NAP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[六种方法实现JavaScript数组去重]]></title>
    <url>%2F2018%2F06%2F28%2F%E5%85%AD%E7%A7%8D%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0JavaScript%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%2F</url>
    <content type="text"><![CDATA[方法1——SetES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 Set本身是一个构造函数，用来生成Set数据结构，Array.from方法可以将Set结构转为数组，在Set内部两个NaN是相等的，两个对象是总不相等的 12345function unique(arr)&#123; return Array.from(new Set(arr));&#125;var arr = [1, 1, 2, 3, null, null, NaN, NaN];console.log(unique(arr)); // [1, 2, 3, null, NaN] 方法2——forEach声明一个数组newArr，直接遍历待去重数组arr，然后把新数组中没有的元素推进去，在forEach中两个NaN不相等 1234567891011function unique(arr)&#123; var newArr = []; arr.forEach(function(item)&#123; if(newArr.indexOf(item) === -1)&#123; newArr.push(item); &#125; &#125;); return newArr;&#125;var arr = [1, 1, 2, 3, null, null, NaN, NaN];console.log(unique(arr)); // [1, 2, 3, null, NaN, NaN] 方法3——reduce在reduce中两个NaN不相等 12345678910function unique(arr)&#123; return arr.reduce(function(prev, next)&#123; if(prev.indexOf(next) === -1)&#123; prev.push(next); &#125; return prev; &#125;, []);&#125;var arr = [1, 1, 2, 3, null, null, NaN, NaN];console.log(unique(arr));// [1, 2, 3, null, NaN, NaN] 12345678var arr = [1, 1, 2, 3, null, null, NaN, NaN];var result = arr.sort().reduce(function(init, current)&#123; if(init.length===0 || init[init.length-1]!==current)&#123; init.push(current); &#125; return init;&#125;, []);console.log(result); //[1, 2, 3, NaN, NaN, null] 方法4——indexOf判断数组元素的indexOf索引判断和元素本身的索引是否相同 如果相同，代表这是数组第一次出现的该元素值 12345678910111213function unique(arr)&#123; var newArr = [arr[0]]; var item; for(var i = 1, len = arr.length; i &lt; len; i++)&#123; item = arr[i]; if(arr.indexOf(item) === i)&#123; newArr.push(item); &#125; &#125; return newArr;&#125;var arr = [1, 1, 2, 3, null, null, NaN, NaN];console.log(unique(arr)); // [1, 2, 3, null] 方法5——优化遍历对数组的每一个元素都进行判断（使用指针i），另一个指针从判断元素的下一位进行判断，移动这个指针（指针j下移），如果发现判断元素与指针指向的值相等，证明该判断元素不是数组中唯一的，那就继续往下判断（指针i下移，指针j回到i的下一位），直到j移到数组终点，证明判断元素（指针i指向的元素）是数组中唯一的并将该元素推入新数组 1234567891011121314function unique(arr)&#123; var newArr = []; for(var i = 0, len = arr.length; i &lt; len; i++)&#123; for(var j = i + 1; j &lt; len; j++)&#123; if(arr[i] === arr[j])&#123; j = ++i; &#125; &#125; newArr.push(arr[i]); &#125; return newArr;&#125;var arr = [1, 1, 2, 3, null, null, NaN, NaN];console.log(unique(arr)); // [1, 2, 3, null, NaN, NaN] 方法6——排序去邻首先调用数组的sort方法对数组的元素进行排序并返回数组，只需要判断数组元素值和上一个索引值不同就可以了 1234567891011121314function unique(arr)&#123; var newArr = [arr[0]]; var item; arr.sort(); for(var i = 1, len = arr.length; i &lt; len; i++)&#123; item = arr[i]; if(item !== arr[i - 1])&#123; newArr.push(item); &#125; &#125; return newArr;&#125;var arr = [1, 1, 2, 3, null, null, NaN, NaN];console.log(unique(arr)); // [1, 2, 3, NaN, NaN, null]]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu下使用和配置shadowsocks]]></title>
    <url>%2F2018%2F06%2F28%2Fubuntu%E4%B8%8B%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AEshadowsocks%2F</url>
    <content type="text"><![CDATA[1. 安装shadowsocks-Qt51sudo add-apt-repository ppa:hzwhuang/ss-qt5 1sudo apt-get update 1sudo apt-get install shadowsocks-qt5 注意！！此处有bug，执行这三条命令不成功的话则找到： 软件和更新-&gt;其他软件-&gt;修改源，将源修改成artful 安装完成后打开shadowsocks界面配置服务器点击连接即可 2. 配置chrome浏览器2.1 安装SwitchOmega 在https://github.com/FelisCatus/SwitchyOmega/releases下载.crx后缀名的文件 在chrome中打开chrome://extensions页面，将下载好的switchOmega插件拖入页面，点击确认即可安装 2.2 配置SwitchOmega 新建情景模式，名称任意，情景模式类型选择代理服务器，点击创建。 点击新建的情景模式进行配置： 点击auto switch进行配置切换模式：]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>shadowsocks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在ubuntu中使用ls和xargs命令转换png和jpg]]></title>
    <url>%2F2018%2F06%2F28%2F%E5%9C%A8ubuntu%E4%B8%AD%E4%BD%BF%E7%94%A8ls%E5%92%8Cxargs%E5%91%BD%E4%BB%A4%E8%BD%AC%E6%8D%A2png%E5%92%8Cjpg%2F</url>
    <content type="text"><![CDATA[PNG转JPG1$ ls -1 *.png | xargs -n 1 bash -c 'convert "$0" "$&#123;0%.png&#125;.jpg"' JPG转PNG1ls -1 *.jpg | xargs -n 1 bash -c 'convert "$0" "$&#123;0%.png&#125;.png"' ls命令可以列出所有的png图像文件，xargs使得可以从标准输入构建和执行convert命令，从而将所有.png图像转换为.jpg图像。 说明： -1：告诉ls每行列出一个图像名称的选项标识 -n：指定最多参数个数，例子中为1 -c：指示bash运行给定的命令 ${0%.png}.jpg：设置新转换的图像文件的名字，%符号用来删除源文件的扩展名]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>ubuntu18.04</tag>
        <tag>jpg</tag>
        <tag>png</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu安装软件]]></title>
    <url>%2F2018%2F06%2F28%2Fubuntu%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[安装ubuntu版TeamViewer 下载软件包：https://www.teamviewer.com/zhcn/download/linux/ 添加32位架构 1$ sudo dpkg --add-architecture i386 更新 1$ sudo apt-get update 安装 1$ sudo dpkg -i teamviewer_13.1.3026_amd64.deb ubuntu安装微信 下载安装包:https://github.com/geeeeeeeeek/electronic-wechat/releases 解压 1tar zxvf linux-x64.tar.gz 找到解压后的electronic-wechat文件，双击运行或者右键选择运行即可 ubuntu安装JDK-8 查看apt库都有哪些jdk版本 1$ apt-cache search java|grep jdk 选择版本进行安装 1$ sudo apt-get install openjdk-8-jdk 设置环境变量 1$ sudo vim /etc/profile 添加以下内容 123456# set java environmentJAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-amd64JRE_HOME=$JAVA_HOME/jreCLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/libPATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/binexport JAVA_HOME JRE_HOME CLASS_PATH PATH 让修改生效 1source /etc/profile 验证 1java -version]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>ubuntu18.04</tag>
        <tag>TeamViewer</tag>
        <tag>微信</tag>
        <tag>jdk-8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu安装WPS]]></title>
    <url>%2F2018%2F06%2F28%2Fubuntu%E5%AE%89%E8%A3%85WPS%2F</url>
    <content type="text"><![CDATA[进入WPS官网下载最新的安装包及字体文件 下载libpng12-0 1wget http://ftp.cn.debian.org/debian/pool/main/libp/libpng/libpng12-0_1.2.49-1+deb7u2_amd64.deb 安装 123sudo dpkg -i libpng12-0_1.2.49-1+deb7u2_amd64.debsudo dpkg -i wps-office_10.1.0.5707_a21_amd64.debsudo dpkg -i wps-office-fonts_1.0_all.deb]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>ubuntu18.04</tag>
        <tag>wps</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu/Mac OSX安装Mongodb]]></title>
    <url>%2F2018%2F06%2F28%2Fubuntu%E5%AE%89%E8%A3%85Mongodb%2F</url>
    <content type="text"><![CDATA[Mac OSX安装mongodb 安装mongodb 1brew install mongodb 启动mongodb 1mongod --config /usr/local/etc/mongod.conf 连接到mongo 1mongo Ubuntu16.04自动安装mongodb 导入包管理系统使用的公钥 1sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 2930ADAE8CAF5059EE73BB4B58712A2291FA4AD5 为mongodb创建一个列表文件 1echo "deb [ arch=amd64,arm64 ] https://repo.mongodb.org/apt/ubuntu xenial/mongodb-org/3.6 multiverse" | sudo tee /etc/apt/sources.list.d/mongodb-org-3.6.list 重新加载本地包数据库 1sudo apt-get update 安装最新版mongodb软件包 1sudo apt-get install -y mongodb-org 查看mongodb版本 1mongod --version 启动mongodb 1sudo service mongod start 开始使用mongodb 12mongouse admin 添加用户名和密码 1db.createUser(&#123;user:'admin', pwd:'r00tme', roles: [ &#123; role: "root", db: "admin" &#125; ]&#125;) 查看所有用户 1show users 其他操作 停止mongodb 1sudo service mongod stop 重新启动mongodb 1sudo service mongod restart 卸载Mongodb 停止mongodb 1sudo service mongod stop 删除包 1sudo apt-get purge mongodb-org* 删除数据目录 12sudo rm -f /var/log/mongodbsudo rm -f /var/lib/mongodb Ubuntu18.04手动安装mongodb 下载所需版本的mongodb二进制文件 1curl -O https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-3.6.4.tgz 从下载的文档中提取文件 1tar -zxvf mongodb-linux-x86_64-3.6.4.tgz 新建文件夹名为mongodb 1mkdir -p mongodb 将解压的文件复制到mongodb文件夹中 1cp -R -n mongodb-linux-x86_64-3.6.4/ mongodb 确保二进制文件的位置在PATH变量中（即将PATH路径指定为mongodb安装路径） 1export PATH=/home/evey/mongodb/mongodb-linux-x86_64-3.6.4/bin:$PATH 创建数据目录 1mkdir -p /data/db 设置数据目录的权限 123chmod 777 data/cd data/chmod 777 db/ 运行mongodb 1mongod 开始使用mongodb 12mongouse admin 添加用户名和密码 1db.createUser(&#123;user:'admin', pwd:'r00tme', roles: [ &#123; role: "root", db: "admin" &#125; ]&#125;) 查看用户 1show users 其他操作 停止mongodb 1Ctrl+C 重新启动mongodb则再次输入mongod即可 1mongod]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>ubuntu16.04</tag>
        <tag>ubuntu18.04</tag>
        <tag>MacOSX</tag>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu安装和配置git]]></title>
    <url>%2F2018%2F06%2F28%2Fubuntu1%2F</url>
    <content type="text"><![CDATA[安装Git1234$ sudo add-apt-repository ppa:git-core/ppa$ sudo apt-get update$ sudo apt-get install git $ git --version 配置Git 指定用户名和邮箱 12$ git config --global user.name "Your Name"$ git config --global user.email "youremail@domain.com" 查看配置 1$ git config --list 解决git pull/git push每次都需要输入密码问题 git bash进入项目目录 执行 1$ git config --global credential.helper store]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[仿ISUX网站动画之图片从左到右加载动画]]></title>
    <url>%2F2018%2F04%2F27%2Fpic-slide%2F</url>
    <content type="text"><![CDATA[背景最近看到ISUX网站动画做的很好看，于是想着能不能实现。现在实现的是图片从左到右加载动画和hover时图片放大。 实现由于我真的录不好屏幕所以没有po出gif图，只能丢链接，想看效果的戳这里 HTML 123&lt;div class="pic-showclip-test"&gt; &lt;div class="pic-showclip"&gt;&lt;/div&gt;&lt;/div&gt; CSS(SCSS) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@mixin pic-showclip($url, $width: 100vw, $height: 100vh, $time: 0.8s, $hover-time: 0.5s) &#123; position: relative; padding-top: $height / $width * 100%; overflow: hidden; animation: pic-showclip-showup-#&#123;$width&#125; #&#123;$time&#125; forwards ease-out; @keyframes pic-showclip-showup-#&#123;$width&#125; &#123; 0%&#123; opacity: 0; transform: translate3d(0, 20px, 0); &#125; 100%&#123; opacity: 1; transform: translate3d(0, 0, 0); &#125; &#125; &amp;::before &#123; content: ' '; position: absolute; display: block; top: 0; left: 0; width: 100%; height: 100%; background-image: url($url); background-repeat: no-repeat; background-position: center center; background-size: cover; animation: pic-showclip-showclip-#&#123;$width&#125; #&#123;$time&#125; forwards cubic-bezier(0, 0.3, 0.7, 1); @keyframes pic-showclip-showclip-#&#123;$width&#125; &#123; 0%&#123; opacity: 0; clip: rect(0, 0, $height, 0); &#125; 100%&#123; opacity: 1; clip: rect(0, $width, $height, 0); &#125; &#125; transform: scale(1); transition: all $hover-time ease; &#125; // hover图片放大 &amp;:hover &#123; &amp;::before &#123; transform: scale(1.05); &#125; &#125; &#125; .pic-showclip-test &#123; max-width: 1260px; margin: 0 auto; .pic-showclip &#123; @include pic-showclip('http://p1cjg886l.bkt.clouddn.com/brands-1.jpg', 1260px, 606px, 0.8s); &#125; &#125; 原理这里封装了一个动画函数名为pic-showclip，里面创建了一个动画名为pic-showclip-showup-#{$width}。 animationanimation常用动画属性有： animation-name: 规定需要绑定到选择器的 keyframe 名称。 animation-duration: 规定完成动画所花费的时间，以秒或毫秒计。 animation-timing-function：规定动画的速度曲线。 animation-delay：规定在动画开始之前的延迟。 animation-iteration-count：规定动画应该播放的次数。 animation-direction：规定是否应该轮流反向播放动画。 animation-fill-mode：规定动画在播放之前或之后，其动画效果是否可见。 animation-timing-functionanimation-timing-function使用名为三次贝塞尔（Cubic Bezier）函数的数学函数。贝塞尔曲线通过控制曲线上的四个点（起始点、终止点以及两个相互分离的中间点）来创造、编辑图形，绘制出一条光滑曲线并以曲线的状态来反映动画过程中速度的变化。 语法： 1animation-timing-function: value; 其中value可取： linear：动画从头到尾的速度是相同的。 ease：默认。动画以低速开始，然后加快，在结束前变慢。 ease-in：动画以低速开始。 ease-out：动画以低速结束。 ease-in-out：动画以低速开始和结束。 cubic-bezier(x1,y1,x2,y2)：在 cubic-bezier 函数中自己的值。可能的值是从 0 到 1 的数值。 以上几种预设速度linear、ease-in、ease-out、ease-in-out均可写成cubic-bezier格式： linear对应自定义cubic-bezier(0,0,1,1)，效果为匀速直线； ease 对应自定义cubic-bezier(.25,.01,.25,1),效果为先慢后快再慢； ease-in 对应自定义cubic-bezier(.42,0,1,1),效果为先慢后快； ease-out 对应自定义cubic-bezier(0,0,.58,1),效果为先快后慢； ease-in-out 对应自定义cubic-bezier(.42,0,.58,1),效果为先慢后快再慢。 1animation: pic-showclip-showclip-#&#123;$width&#125; #&#123;$time&#125; forwards cubic-bezier(0, 0.3, 0.7, 1); cubic-bezier(0, 0.3, 0.7, 1);反映的效果是慢慢变快，平滑过渡 animation-fill-modeanimation-fill-mode规定动画在播放之前或之后，其动画效果是否可见。 语法是： 1animation-fill-mode : none | forwards | backwards | both; none: 不改变默认行为。 forwards: 当动画完成后，保持最后一个属性值（在最后一个关键帧中定义）。 backwards: 在 animation-delay 所指定的一段时间内，在动画显示之前，应用开始属性值（在第一个关键帧中定义）。 both: 向前和向后填充模式都被应用。 clipclip属性的语法是这样定义的： 1clip: &lt;shape&gt; | auto 注意！！！clip 属性仅在设置了 position: absolute | fixed 的元素上生效且&lt;shape&gt; 仅接受 rect() 矩形裁切。 rect() 接受四个值： 1clip: rect(&lt;top&gt;, &lt;right&gt;, &lt;bottom&gt;, &lt;left&gt;) 其中&lt;top&gt; 和 &lt;bottom&gt; 指定相对于盒子上边框边界的偏移，&lt;right&gt; 和 &lt;left&gt; 指定了相对于盒子左边框边界的偏移。即可以把 &lt;top&gt; 和 &lt;bottom&gt; 想象成 Photoshop 中的水平参考线，&lt;right&gt; 和 &lt;left&gt; 是垂直参考线，而剪裁区域就是它们所围成的矩形区域。 当 bottom &lt;= top 或者 right &lt;= left 时，裁切区域不显示 12345678910@keyframes pic-showclip-showclip-#&#123;$width&#125; &#123; 0%&#123; opacity: 0; clip: rect(0, 0, $height, 0); &#125; 100%&#123; opacity: 1; clip: rect(0, $width, $height, 0); &#125;&#125; 这段代码实现的功能就是先把一部分图片隐藏，然后平滑显示。 transformscale属性的语法为： 1transform: scale(&lt;x&gt; [&lt;y&gt;]) 通过scale()，根据给定的宽度（X 轴）和高度（Y 轴）参数，元素的尺寸会增加或减少。 12345&amp;:hover &#123; &amp;::before &#123; transform: scale(1.05); &#125;&#125; 这段代码实现的功能是当图片hover时，图片放大1.05倍]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css实现居中]]></title>
    <url>%2F2018%2F04%2F25%2Fcenter%2F</url>
    <content type="text"><![CDATA[translate+position实现居中HTML 123&lt;div class="menu"&gt; &lt;span&gt;dhsl&lt;/span&gt;&lt;/div&gt; CSS 123456.menu &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);&#125;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>居中</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动画封装之字体动画]]></title>
    <url>%2F2018%2F04%2F25%2Ffont-animation%2F</url>
    <content type="text"><![CDATA[背景早上看到这个动画觉得好奇妙，然后官网又需要做优化，于是想想能不能封装起来用到官网乃至以后的项目中去。 难点所在一般来讲hover就是从哪里来，回哪里去，比如： 现在的难点在于如何在hover离开的时候改变动画行进的方向。 hover动画可以分解为三个部分： hover进入状态 hover停留状态 hover离开状态 一般来说hover transition动画只有两种状态即正常状态和hover状态：正常状态-&gt;hover状态-&gt;正常状态 div { ……. } div:hover { ….. } 所以，必须要有一种方法能够使得hover动画进入与离开的状态产生两种不同的效果，实现：状态1-&gt;hover状态-&gt;状态2 解决关键实现本文开头的动画的关键点在于使得hover动画的进入与离开产生不一样的效果。使用transform:scale()和transform-origin可以实现这个效果。 transform:scale()实现线条运动transform:scale()通俗来说是用于缩放，用官方的话说就是： CSS 函数 scale() 用于修改元素的大小。可以通过向量形式定义的缩放值来放大或缩小元素，同时可以在不同的方向设置不同的缩放值。 我们这里使用transform: scaleX(0)与 transform: scaleX(1)来改变线条的显示与隐藏。 transform-origin实现线条运动方向官方解释： transform-origin属性可以使用一个，两个或三个值来指定，其中每个值都表示一个偏移量。 没有明确定义的偏移将重置为其对应的初始值。 如果定义了两个或更多值并且没有值的关键字，或者唯一使用的关键字是center，则第一个值表示水平偏移量，第二个值表示垂直偏移量。 我们给线条设置一个默认的transform-origin 记为状态1，hover时设置另一个不同的transform-origin 记为状态2，所以当我们hover时，会读取状态2的transform-origin，从原点放大至scaleX(1)，hover离开的时候读取状态1的transform-origin，从scaleX(1)状态缩小至该原点。 动画封装HTML 1&lt;div class="a"&gt;Hover Me&lt;/div&gt; CSS(SCSS) 12345678910111213141516171819202122232425262728293031@mixin font-animation($color: #666, $border-color: #999) &#123; position: relative; display: inline-block; cursor: pointer; color: rgba($color, .7); transition: all .5s; &amp;::before &#123; content: ""; position: absolute; left: -5%; bottom: 0; width: 110%; transform: scaleX(0); height: 2px; background: $border-color; z-index: -1; transition: transform .5s; transform-origin: 100% 0; &#125; &amp;:hover &#123; margin-left: .5em; color: $color; &amp;::before &#123; transform: scaleX(1); transform-origin: 0 0; &#125; &#125;&#125;.a &#123; @include font-animation&#125; 最后可以感受一下transition: transform .5s;和transition: all .5s;的区别。 demo戳这里]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>animation</tag>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[值得收藏的网站]]></title>
    <url>%2F2018%2F04%2F24%2Fwebsite-address%2F</url>
    <content type="text"><![CDATA[毕业论文/毕设 Docx88.com 文库大全、免费文库资料下载，可以复制文章后面的code到百度文库打开查看原文。 比如，在Docx88.com搜索到的文章url是http://www.docx88.com/wkid-11312839e97101f69e3143323968011ca300f7e2-11.html，则在百度文库中的地址为：https://wenku.baidu.com/view/11312839e97101f69e3143323968011ca300f7e2-11.html paperpass 论文查重 知网 工具类 蓝湖 团队工作平台，sketch的好朋友 processOn 免费在线作图，实时协作 正则调试工具1 正则调试工具2*%3F%24) jsplumbtoolkit 画流程图的软件 Json.cn Json在线解析格式 web开发速查表 超实用的！！比如查css flex，就会看到flex的基本用法和所有属性 css参考手册 jsbin js在线编辑器]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>网址</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Nuxt.js项目中如何使用ElementUI]]></title>
    <url>%2F2018%2F04%2F04%2Fnuxt-element%2F</url>
    <content type="text"><![CDATA[背景在写后台管理系统的界面，发现很难写出一个好看的表单（主要是懒），于是想用UI插件，首选当然是熟悉的ElementUI，之前都是在Vue项目中使用的ElementUI，这次第一次玩Nuxt，不知道该怎么取引用，当然首选是官网教程-插件的使用。 在Nuxt中使用ElementUI很简单，只需要三步： 安装ElementUI npm i element-ui -S 修改nuxt配置文件nuxt.config.js，添加以下内容 在plugins文件夹下新建一个文件element-ui.js 操作nuxt.config.js12345678910111213141516171819202122module.exports = &#123; build: &#123; vendor: ['axios', 'element-ui'] &#125;, css: [ &#123; src: 'element-ui/lib/theme-chalk/index.css', ssr: true &#125; ], babel: &#123; "plugins": [["component", [ &#123; "libraryName": "element-ui", "styleLibraryName": "theme-default" &#125;, 'transform-async-to-generator', 'transform-runtime' ]]], comments: true &#125;, plugins: [ '~plugins/element-ui' ]&#125; element-ui.js1234import Vue from 'vue'import ElementUI from 'element-ui'Vue.use(ElementUI)]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Nuxt.js</tag>
        <tag>ElementUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组求和]]></title>
    <url>%2F2018%2F04%2F04%2Farray-sum%2F</url>
    <content type="text"><![CDATA[问题描述： 计算给定数组arr中所有元素的总和。 例： 输入[1,2,3,4] 输出：10 常规循环：1234567function sum(arr) &#123; var s = 0; function(var i=arr.length-1;i&gt;=0;i--) &#123; s+=arr[i]; &#125; return s;&#125; 思路：arr=[1,2,3,4]，i=arr.length-1=4-1=3 s0=0+arr[3]=0+4=4; s1=4+arr[2]=4+3=7; s2=7+arr[1]=7+2=9; s3=9+arr[0]=9+1=10; forEach遍历：1234567function sum(arr) &#123; var s = 0; arr.forEach(function(val,index,arr) &#123; s+=val; &#125;,0) return s;&#125; forEach传送门 val:数组中正在处理的当前元素 index:数组中正在处理的当前元素的索引 arr:forEach()方法正在操作的数组 例如:arr=[1,2,3,4]，则 s0=s+val0=0+1=1; s1=s0+val1=1+2=3; s2=s1+val2=3+3=6; s3=s2+val3=6+4=10; reduce方法：12345function sum(arr) &#123; return arr.reduce(function(prev, curr, idx, arr)&#123; return prev + curr; &#125;);&#125; reduce传送门 prev:累加器累加回调的返回值 curr:数组中正在处理的元素 idx:数组中正在处理的当前元素的索引 arr:调用reduce的数组 例如：arr=[1,2,3,4]，则共经历4轮 prev=0,curr=1,return 0+1=1 （第一轮累加器累加毁掉的返回值为0） prev=1,curr=2,return 1+2=3 prev=3,curr=3,return 3+3=6 prev=6,curr=4,return 6+4=10 eval：123function sum(arr) &#123; return eval(arr.join("+"));&#125;; eval传送门 例如:arr=[1,2,3,4]，则 return 1+2+3+4=10]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>数组求和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于element-ui表单验证方法封装]]></title>
    <url>%2F2018%2F01%2F24%2FeleValidatePackage%2F</url>
    <content type="text"><![CDATA[背景最近在做重构项目的表单验证，发现element-ui自带的表单校验内置方法太少了，不能满足日常工作需求，如果需要校验的表单多，就会做很多重复的工作，所以把校验方法包括自定义校验规则封装起来便于调用。 使用主要文件有两个，eleValidate.vue和valiate.js eleValidate.vue封装后的loginRules只需要传参就可以了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;template&gt; &lt;div class="login-container"&gt; &lt;el-form autoComplete="on" :model="loginForm" :rules="loginRules" ref="loginForm" label-position="left" label-width="0px" class="card-box login-form"&gt; &lt;el-form-item prop="username"&gt; &lt;el-input name="username" type="text" v-model="loginForm.username" autoComplete="on" placeholder="用户名"/&gt; &lt;/el-form-item&gt; &lt;el-form-item prop="password"&gt; &lt;el-input name="password" v-model="loginForm.password" autoComplete="on" placeholder="密码"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;el-button type="primary" style="width:100%;"&gt; 登陆 &lt;/el-button&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import validate from '../validate'export default &#123; name: 'login', data () &#123; return &#123; loginForm: &#123; username: '', password: '' &#125;, loginRules: &#123; username: [ &#123; validator: validate('name', '用户名由字母、数字、下划线以及短横线组成。', '用户名不能为空！'), trigger: 'blur' &#125;, &#123; max: 50, message: '用户名最多为50个字符！', trigger: 'blur' &#125; ], password: [ &#123; validator: validate('passWord', '密码由字母、数字及下划线组成。', '密码不能为空！'), trigger: 'blur' &#125;, &#123; max: 25, message: '密码最多为25个字符！', trigger: 'blur' &#125; ] &#125; &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt; .login-container &#123; width: 300px; margin: 0 auto; margin-top: 100px; &#125;&lt;/style&gt; validate既可以传参数名也可以传正则表达式，例如： 123&#123; validator: validate(&apos;name&apos;, &apos;用户名由字母、数字、下划线以及短横线组成。&apos;, &apos;用户名不能为空！&apos;), trigger: &apos;blur&apos; &#125;或者&#123; validator: validate(&apos;/^([\w-]+|[\u4e00-\u9fa5]+)$/&apos;, &apos;用户名由字母、数字、下划线以及短横线组成。&apos;, &apos;用户名不能为空！&apos;), trigger: &apos;blur&apos; &#125; validate.js这个文件主要写自定义正则表达式和处理传进来的参数。 1reg = pattern[reg] ? pattern[reg] : reg 这句话的作用就是既可以传定义好的参数名，也可以直接传正则表达式，传进来以后自动检测是否存在（已经定义） 1234567891011121314151617181920212223242526272829303132/** * 正则库 */const pattern = &#123; name: /^([\w-]+|[\u4e00-\u9fa5]+)$/, // 用户名校验 passWord: /^\w+$/ // 密码校验&#125;/** * 内置规则 * @param &#123;String&#125; reg - &#123;pattern&#125;中预定义正则名称 or 自定义正则 * @param &#123;String&#125; msg1 - 正则校验不通过提示 * @param &#123;String&#125; msg2 - 值为空时提示（可不填） */const validate = (reg, msg1, msg2) =&gt; &#123; return (rule, value, callback) =&gt; &#123; if (!value) &#123; if (!msg2) &#123; callback() &#125; callback(new Error(msg2)) &#125; reg = pattern[reg] ? pattern[reg] : reg if (!reg.test(value)) &#123; callback(new Error(msg1)) &#125; else &#123; callback() &#125; &#125;&#125;export default validate 传送门源码戳这里 小结封装以后确实很好用，省了很多工作，就是内置的规则很少，写正则麻烦。]]></content>
      <categories>
        <category>validate</category>
      </categories>
      <tags>
        <tag>element-ui</tag>
        <tag>封装</tag>
        <tag>表单校验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Submodules子模块解决Hexo第三方主题同步更新问题]]></title>
    <url>%2F2018%2F01%2F24%2Fsubmodules%2F</url>
    <content type="text"><![CDATA[现象从远程仓库clone到本地的hexo博客无法启动，提示“WARN：NO layout：index” 问题hexo博客的next主题不能更新到远程仓库（github），远程仓库的主题文件夹为空。 解决方案一：重新clone一个新的next主题到本地从github上clone博客代码到本地后，重新clone一次next主题到本地。 具体操作： 1234567$ git clone https://github.com/Evey-huang/Blog.git (克隆远程代码到本地)$ cd Blog (进入博客根目录)$ npm install (视情况而定，安装依赖)$ rm -rf themes/next/ (移除空的主题目录)$ git clone https://github.com/Evey-huang/hexo-theme-next.git themes/next (克隆新的主题并指定本地存储目录为 themes/next)$ hexo g (部署)$ hexo s (启动) 弊端：每次都要这么做，如果你的主题有自定义，那么每次都要更新配置文件，因为重新clone下来的主题是初始的。 二：使用git submodule管理子模块什么是submodule？git submodule是一个多项目使用共同类库的工具，允许类库项目做为repository，子项目作为一个单独的git项目存在父项目中，子项目可以有自己独立的commit，push，pull。而父项目以submodule的形式包含子项目，父项目可以指定子项目header，父项目中的提交信息包含submodule的信息，在clone父项目的时候可以把submodule初始化。 在这里，博客Blog为父项目，hexo next主题为子项目独立存在于Blog中。 解决第三方库更新问题就是fork+submodule。即先在github上fork next主题仓库，然后再使用submodule。 具体操作： 12345$ git clone https://github.com/Evey-huang/Blog.git (克隆远程代码到本地)$ cd Blog (进入博客根目录)$ npm install (视情况而定，安装依赖)$ rm -rf themes/next/ (移除空的主题文件夹)$ git submodule add https://github.com/Evey-huang/hexo-theme-next.git themes/next (克隆新的主题并指定本地存储目录为 themes/next) 在执行第5步时出现了下面这个问题： 1&apos;themes/next&apos; already exists in the index 解决方案： 1$ git rm -r --cached themes/next 然后再次执行第5步： 1$ git submodule add https://github.com/Evey-huang/hexo-theme-next.git themes/next 修改.git/config和.git/module/themes/next/config文件，在github前面加上自己的github名称Evey-huang@（不修改的话提交代码会因为没有权限而失败）： 1$ vim .git/config 1$ vim .git/module/themes/next/config 做完以上修改后，可以更新next主题的配置，将自己的自定义配置覆盖原来的配置，然后提交到远程仓库Evey-huang/hexo-theme-next 1234$ cd themes/next$ git add .$ git commit -m "update"$ git push origin master 提交成功可以在github上看到有更改： 分割线—————————————————————————— 以上是添加submodule以及更新next主题的全部步骤，做完这些，无论你换多少台电脑都可以快速地开始工作更新文章啦~ 换了电脑后如何快速开始工作？ 具体操作： 1234567$ git clone https://github.com/Evey-huang/Blog.git$ cd Blog$ git submodule update --init$ cd themes/next$ git pull origin master (如果不做这一步，就不能更新到最新的配置)$ hexo g$ hexo s 小结其实之前就已经发现每次next主题都不能更新到github，但是工作没有受到影响就忽略了，一直拖着不解决这个问题，直到遇到了才去解决，一开始就胡乱去google得到很多教程，跟着几遍下来发现都不成功，觉得自己大概是[中了邪了]，后面仔细看了官方解释才对submodule有深入的了解，知道其工作原理，然后梳理一下思路才慢慢做成功了，于是有了这篇文章，回过头去看步骤真的很简单，只怪自己当时没看清。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>submodule</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[饿了么element表单验证插件]]></title>
    <url>%2F2018%2F01%2F20%2FelemeValidate%2F</url>
    <content type="text"><![CDATA[背景为什么又换表单验证插件，记得上一次是Vuelidate。emm,没错，我们项目重构了，前端组件库从quasar换成了element，相应的，把表单验证插件也从vuelidate换成了element支持的校验规则async-validator。 介绍element表单校验规则很简单，只需要通过 rules 属性传入约定的验证规则，并把 Form-Item 的 prop 属性设置为需校验的字段名即可，官网写得很详细，很容易上手，传送门—&gt;表单验证 内置的校验规则肯定满足不了工作需求，所以自定义校验显得尤为重要，这里主要写自定义规则和内置规则如何搭配使用。 开始HTML新建一个表单Form包含两个input，分别为用户名和密码 12345678910111213141516171819&lt;script src="//unpkg.com/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script src="//unpkg.com/element-ui@2.0.11/lib/index.js"&gt;&lt;/script&gt;&lt;div id="app"&gt;&lt;el-form :model="ruleForm2" status-icon :rules="rules2" ref="ruleForm2" label-width="100px" class="demo-ruleForm"&gt; &lt;el-form-item label="用户名" prop="username"&gt; &lt;el-input type="text" v-model="ruleForm2.username" auto-complete="off"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label="密码" prop="pass"&gt; &lt;el-input type="password" v-model="ruleForm2.pass" auto-complete="off"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;el-button type="primary" @click="submitForm('ruleForm2')"&gt;登录&lt;/el-button&gt; &lt;el-button @click="resetForm('ruleForm2')"&gt;重置&lt;/el-button&gt; &lt;/el-form-item&gt;&lt;/el-form&gt;&lt;/div&gt; JS用户名校验规则为： 必填，不能为空 最长为5个字符（写的数比较小是为了用于测试） 由字母数字下划线还有短横线组成 密码校验规则为： 必填，不能为空 最长6个字符（同上） 由字母数字下划线组成 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960var Main = &#123; data() &#123; var validateUser = (rule, value, callback) =&gt; &#123; if (value === '') &#123; return callback(new Error('用户名不能为空')); &#125; if (!/^[\w-]+$/.test(value)) &#123; callback(new Error('用户名由字母、数字及下划线或者短横线组成')) &#125; else &#123; callback() &#125; &#125;; var validatePass = (rule, value, callback) =&gt; &#123; if (value === '') &#123; callback(new Error('请输入密码')) &#125; if (!/^\w+$/.test(value)) &#123; callback(new Error('密码由字母、数字及下划线组成')) &#125; else &#123; callback() &#125; &#125;; return &#123; ruleForm2: &#123; pass: '', username: '' &#125;, rules2: &#123; pass: [ &#123; required: true，validator: validatePass, trigger: 'blur' &#125;, &#123; max: 6, message: '密码最多为6个字符', trigger: 'blur' &#125; ], username: [ &#123; required: true，validator: validateUser, trigger: 'blur' &#125;, &#123; max: 5, message: '用户名最多为5个字符', trigger: 'blur' &#125; ] &#125; &#125;; &#125;, methods: &#123; // 点击登录时触发 submitForm(formName) &#123; this.$refs[formName].validate((valid) =&gt; &#123; if (valid) &#123; alert('submit!'); &#125; else &#123; console.log('error submit!!'); return false; &#125; &#125;); &#125;, // 对整个表单进行重置，将所有字段值重置为初始值并移除校验结果 resetForm(formName) &#123; this.$refs[formName].resetFields(); &#125; &#125; &#125;var Ctor = Vue.extend(Main)new Ctor().$mount('#app') CSS因为懒得写css所以引的element-ui自带css样式 1@import url("//unpkg.com/element-ui@2.0.11/lib/theme-chalk/index.css"); 传送门戳这里在线运行代码 效果图原始样式 当input输入框为空时点击登录或者离开输入框都会提示不能为空 当输入字符超过限定时会提示最多为xxx字符 当出现非法字符串比如”?”也会提醒 小结总的来说这个验证插件要比vuelidate好用，在当前页面就可以完成验证工作，而vuelidate还需要依赖很多文件，要自定义一个校验方法需要改好几个文件。 最后，校验插件好上手，难的是校验规则，要想校验好正则少不了~]]></content>
      <categories>
        <category>validate</category>
      </categories>
      <tags>
        <tag>element</tag>
        <tag>表单验证</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用ES6的浏览器兼容性问题]]></title>
    <url>%2F2018%2F01%2F20%2Fes6%2F</url>
    <content type="text"><![CDATA[背景最近项目重构需要添加单元测试环境到项目中去，由于之前已经有了经验和写了教程，直接照着来就是了，但是却出现了bug。 问题Google发现这是一个es6浏览器兼容性问题。 polyfill由于Babel默认只转换各种ES2015语法，而不转换新的API，比如Promise，这时我们需要提供一些ployfill来模拟出这样一个提供原生支持功能的浏览器环境。主要有两种方式：babel-runtime和babel-polyfill，这里主要讲babel-polyfill。 babel-polypillbabel-polyfill是针对全局环境的，引入它浏览器就好像具备了规范里定义的完整的特性，一旦引入，就会跑一个babel-polyfill实例。 用法： 安装 1npm install --save-dev babel-polyfill 在入口文件引入 1import 'babel-polyfill' 解决方案本次bug的引起主要是因为添加了单元测试环境，所以引入的时候应该在单元测试环境配置文件里引入，在karma.conf.js中files字段中引入： 1'../../node_modules/babel-polyfill/dist/polyfill.js' 具体这样： 1234files: [ '../../node_modules/babel-polyfill/dist/polyfill.js', './index.js' // 入口文件], 小结浏览器兼容是个坑。]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《单恋》]]></title>
    <url>%2F2018%2F01%2F12%2Fdanlian%2F</url>
    <content type="text"><![CDATA[《单恋》主要是围绕一个杀人事件展开调查最后牵出因性别而烦恼的一个特殊人群。 故事梗概中尾功辅、西胁哲朗、高仓理沙子还有日浦美月都是大学时代美式橄榄球队的成员，中尾毕业以后入赘高城家，因为有一个内心是男人的母亲而研究起性别差异并与嵯峨正道创办了金童剧团来为因性别而烦恼的人群解决身份户籍问题。日浦美月患有性别识别障碍，时而是女性时而是男性，顺应父母做一个正常的女孩子而相亲结婚并且生下一个孩子，但是想做男人的愿望特别强烈所以还是离开了家，去寻找自己想要的生活。 在佐伯香里的介绍下进入了猫眼工作，户仓明雄跟踪佐伯香里，为了保护香里日浦形影不离地保护她，户仓明雄很生气调查到日浦其实是个女人，为了羞辱她进而对她施暴，还好中尾及时赶到施暴未遂，中尾因为愤怒杀死了户仓明雄。 美月想要顶替中尾去自首，但是很舍不得昔日的好友，便决定先去见一见哲朗他们，这一次的相见引发了大家的想追寻真想的好奇心，哲朗和理沙子围绕美月杀人以及美月失踪展开了调查然后慢慢接近了真相，原来中尾和美月的背后有着一群因为性别而烦恼的人，他们有些是生来是女儿身但是却有着男儿心，有些事男人的身体却想以女人的身份去生活，想真正以异性的身份去生活户籍是个大问题，中尾和嵯峨就致力于帮助他们过上自己想要的生活而努力。想要保护好友而终止调查的时候却发现事情失去了控制。 若因杀人事件而使这一特殊人群曝光，之前所做的努力就会付之东流，这时已经身怀而哲朗、理沙子还有早田也以自己的方式帮助着他们。 结局的最后是一切尘埃落定，因为中尾的牺牲那个特殊人群得以平静地生活。 想说几句对于性别的解释，书中用麦比乌斯环来做比喻。“如果是一张普通的纸，那么反面永远是反面，正面永远是正面，两者没有交会的机会。但若换成麦比乌斯环，正面却会在不知不觉间成了反面。正反面紧密相连。这个世界上所有的人都在这麦比乌斯环上，不存在完全的女人，也不存在完全的男人。” 这其中的代表就是日浦美月，美月说自己的内心是个男人，至少在丈夫和外人面前是，但是在中尾交往的时候，和哲朗发生关系的时候，拍成人礼照片的时候透露出来的都是不折不扣的女人，她的父亲、中尾和哲朗都是这样坚信，但是和理沙子在一起的时候，理沙子却说感受到她是以男人方式存在的，最后她和中尾一体同心，她既是中尾也是日浦，十多年的单恋修成正果，是很幸福的事。 后面理沙子和哲朗还是分开了，关于大学最后一场比赛输了，理由是因为哲朗左眼视力不好导致丢球，但是这个原因他从来没有对大家说过，只有中尾和早田知道，甚至是最亲密的伴侣他的妻子理沙子，他也不曾开口，后面理沙子说的“你是不是决定到死也不让我进入你的世界，也就是所谓的男人的世界？那个世界有多夸张？是圣地？女人进入那个世界，对男人来说有那么严重吗？”，太过鲜明地划分男人和女人的世界了。理沙子和哲朗这一对校园恋人走进婚姻八年最终还是分手收场，让我想起最近火热的电影《前任3》，讲的是错过了就回不去了，但我是想为什么在这个错过形成之前不把问题解决了呢，恋人间不是应该多沟通吗，有什么就讲清楚然后再一起去解决，而不是一直等对方开口，最后这样错过。 最后很意外的是早田帮助哲朗他们逃跑，一开始觉得早田很在意他的工作虽不会给他们添麻烦但也不至于帮忙，但是最后的举动让人很意外，原来近端锋不仅要接好传过来的球，为了保护四分位还需要参与防守。 第一次看关于性别探讨的的书籍，类似影视作品也看过，但是第一次对性别有个深刻的认识还是看完《单恋》以后。我想我们不应该为了性别而去烦恼，因为自己有个异性的心就一定要变成异性去生活，就应该像书中的相川冬纪和末永睦美一样，男的女的好的坏的都是自己，应该学会去接受自己。 我就是我，不一样的烟火。]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>单恋</tag>
        <tag>东野圭吾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何正确“反孔”]]></title>
    <url>%2F2018%2F01%2F04%2Fmaokong%2F</url>
    <content type="text"><![CDATA[写这篇文章的起因今天朋友问有什么好的化妆棉推荐（女孩子最喜欢吃安利）。我说看是有什么用途咯，不同用途都有不同的化妆棉推荐，比如卸妆用一般化妆随便什么都无所谓啦，湿敷的话只用过一款就是尤妮佳省水1/2那一款。朋友就说用来敷城野医生控油收缩毛孔化妆水，觉得这个可以收缩毛孔，而且觉得毛孔好像真的变小了（都是假象！），听到这里我按捺不住跳起来就是一波科普，我要让我的朋友们科学护肤。 什么才是毛孔粗大的真正原因我对毛孔很关心的一大原因在于我也受困于毛孔粗大问题，没错！就是小时候不懂事仗着有大把胶原蛋白使劲折腾什么也敢往脸上呼还使劲晒太阳把脸折腾坏了，靠近鼻子的脸颊毛孔比较粗大。再加上身边朋友的吐槽，让我知道我不是一个人，有很多人很在意毛孔粗大问题，而且！很多人对毛孔都没有正确的认识，不从根本去解决而采用简单粗暴的方法——化妆，使用厚厚的粉底遮住了毛孔，但是素颜的时候毛孔还是这么粗大。（废话讲的有点多） 毛孔粗大的原因不外乎有三： 皮脂分泌旺盛 日光照射 老化 皮脂分泌旺盛皮脂分泌旺盛讲大白话就是出油多。 我们每个毛孔里面不仅只有一根汗毛，它的侧壁上面往往连接着一个皮脂腺。皮脂腺最重要的作用是分泌皮脂（皮脂是皮肤屏障功能的重要组成），这些皮脂会从皮脂腺中流到毛囊的管道中，然后一路向上到达皮肤表面。均匀分布在皮肤表面的皮脂不仅仅能够润泽皮肤还有一定抗菌作用。 皮脂分泌旺盛为什么导致毛孔粗大毛孔粗大的原因，很大程度上是由于皮脂量大，来不及流出被堵住，原来排列得很紧致均匀的胶原蛋白队列，长期被一颗堵在毛孔里面的油脂挤压之后变性无法复原，然后毛孔就变大了。 至于为什么会导致皮脂分泌量大，原因可能是多种的，有可能是激素原因，也有可能是由于不正当地使用产品导致，还有可能是因为身体疾病。 如何控制皮脂分泌想要控制油脂分泌达到控制毛孔的目的，一方面是注意身体健康和饮食均衡（很多皮肤问题这条都适用），另一方面可以通过护肤品来实现，比如维A醇（醛）、果酸、水杨酸、烟酰胺和PCA锌。目前只用过烟酰胺和PCA锌，对应的产品是ISDIN怡思丁控油调理乳液和OLAY小绿瓶（没有广告费没有广告费！！）个人体验，PCA锌见效快，烟酰胺就走温和持续路线，要坚持用很久才能见效。 日光照射除了堵塞的油脂能伤害胶原蛋白之外，日光是另一个真正的杀手。日光中的紫外线激发出来的大量氧自由基不停进攻胶原蛋白，这样会造成大面积的皮肤松弛，而松弛的结果之一就是毛孔粗大。 So！！要注意防晒！！要防晒！！要防晒！！（重要的事情说三遍），听说我朋友从来不涂防晒霜老衲的心里一阵痛。 老化基于以上两条，如果没有皮脂分泌过量和阳光照射，毛孔是不是不会粗大？想得美！！ 随着年龄的增长，我们终究是要老去的，我们慢慢地会失去皮肤的弹性，新生的胶原蛋白也没有原来的那么规整（胶原蛋白更新的周期是十年，可不可怕），这样毛孔就会慢慢变粗大。 So！使用抗老化的产品也可以缓解毛孔粗大的问题。抗老化的成分比如有维生素C、维A醇等。 已经形成的粗大毛孔对于已经形成的粗大毛孔该怎么办？没什么办法，只有医美了。所以预防很重要！ 回到最初朋友讲的城野医生控油收缩毛孔化妆水可以收缩毛孔，其实这个产品主要是用酸来作为主要的功能支撑。 乳酸和苹果酸可以加快最表层皮肤老化角质层脱落过程，某种程度上缩小毛孔（已经被撑大了的毛孔是很难通过护肤品达到真正的缩小）。 还有薄荷氧基丙二醇和辣薄荷提取物，这两个的主要功能就和冰敷差不多，有清凉感，让你在使用后能够短暂地感觉到效果，觉得毛孔有变小（醒醒吧，别骗自己了！！） 讲这么多就是想让姑娘们理性护肤，别听微博大V安利了你就屁颠屁颠也去买来用，把脸作坏了不说，主要是我心疼钱啊。]]></content>
      <categories>
        <category>护肤</category>
      </categories>
      <tags>
        <tag>毛孔</tag>
        <tag>护肤</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈2017-12读书]]></title>
    <url>%2F2018%2F01%2F04%2Fkanjian%2F</url>
    <content type="text"><![CDATA[最近看了六本书，也就是封面的这六本，说好的看《南京大屠杀》也是没看几页，光是看个序都泪眼朦胧分分钟要决堤那种。 当你的才华还撑不起你的梦想时这本书光看题目就知道是鸡汤类型的了，作者是特立独行的猫，反正没听过，据说是微博大V可惜我不玩微博。整体来说还算正能量吧，但是来来去去都是讲的那几个故事，实在没新意，而且别人的人生别人的成功是不可复制的，还是少看这类书好了。 老了依旧可以谈谈未来蔡澜老先生的书，无处不透露着他的洒脱。很稀松平常的家常话但又透露着人生哲理，值得思考。老了依然可以谈未来读后感 恶意恶意总是让我想起有校园暴力的青少年们，总是不能理解他们怎么可以狠得下心去欺负那些无辜的人，也许是我没有经历他们所经历的，我的愿望是世界和平。恶意读后感 白夜行白夜行这本书看了蛮久了大概有一周多的时间，人物网拉得很大错综复杂。看完这本书五味杂陈，既为亮司和雪穗之间的爱情故事感到惋惜——他们最终没有在一起。也为他们所犯下的罪行感到愤怒——这19年间为了“扫除障碍”不断地杀人，而他们杀的第一个人就是他们的父母。如果不耐心看下去，了解这些背景，可能会觉得他们就是十恶不赦的人，了解了背景以后又开始心疼他们。我也有去看一些书评，很多都在批判他们两个人罪大恶极，视人命为草芥，我自己也和朋友交流了一下感想，最终结论就是保留自己的看法也不拒绝其他看法。 看见看这本书是哭得最多次的，从非典那一段开始哭，在地铁上哭得跟傻逼一样。看这本书思考很多，年轻时候的柴静让我想到了现在的自己，很菜鸟，初入职场，会怀疑自己的能力也会自信心爆棚，有听不进别人的建议的时候也有跪求建议的时候，总之这本书让我受益良多，看完以后跟销售一样跟周围朋友使劲安利这本书，不知道有多少个会去看，但是就是忍不住hh。 愿你成为最好的女子这本书跳着看的，觉得还好吧，实在无聊可以看，但是不怎么推荐看。]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
        <tag>柴静</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli脚手架webpack模板项目配置文件分析]]></title>
    <url>%2F2017%2F12%2F29%2Fwebpack%2F</url>
    <content type="text"><![CDATA[背景最近学习单元测试配环境的时候一直出错，然后被指点说应该先去学习webpack工作原理再去配环境。然后就去学webpack了，觉得有必要把webpack配置文件的代码解释记录下来，便于学习。 文件结构123456789101112131415└── build └── build.js ├── check-versions.js ├── utils.js ├── vue-loader.conf.js ├── webpack.base.conf.js ├── webpack.dev.conf.js ├── webpack.prod.conf.js └── webpack.test.conf.js├── config ├── dev.env.js ├── index.js ├── prod.env.js └── test.env.js└── package.json 指令分析首先看package.json里面的script字段 12345678"scripts": &#123; "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js", "start": "npm run dev", "unit": "cross-env BABEL_ENV=test karma start test/unit/karma.conf.js --single-run", "test": "npm run unit", "lint": "eslint --ext .js,.vue src", "build": "node build/build.js"&#125;, 先看build和dev。运行npm run dev时执行的是build/webpack.dev.conf.js，运行npm run build执行的是build/build.js，然后可以先从这两个文件开始分析。 build文件夹分析webpack.dev.conf.js开发环境下执行npm run dev的时候最先执行build/webpack.dev.conf.js文件，该文件主要做以下几件事： 合并基础的webpack配置 配置webpack插件 代码注释： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182'use strict'const utils = require('./utils')const webpack = require('webpack')const config = require('../config')const merge = require('webpack-merge') // 一个可以合并数组和对象的插件const baseWebpackConfig = require('./webpack.base.conf') // 合并webpack基础配置const HtmlWebpackPlugin = require('html-webpack-plugin') // 一个用于生成HTML文件并自动注入依赖文件（link/script）的webpack插件const FriendlyErrorsPlugin = require('friendly-errors-webpack-plugin') // 用于更友好地输出webpack的警告、错误等信息const portfinder = require('portfinder')const HOST = process.env.HOSTconst PORT = process.env.PORT &amp;&amp; Number(process.env.PORT)const devWebpackConfig = merge(baseWebpackConfig, &#123; module: &#123; rules: utils.styleLoaders(&#123; sourceMap: config.dev.cssSourceMap, usePostCSS: true &#125;) &#125;, // cheap-module-eval-source-map is faster for development devtool: config.dev.devtool, // these devServer options should be customized in /config/index.js devServer: &#123; clientLogLevel: 'warning', historyApiFallback: true, hot: true, compress: true, host: HOST || config.dev.host, port: PORT || config.dev.port, open: config.dev.autoOpenBrowser, overlay: config.dev.errorOverlay ? &#123; warnings: false, errors: true &#125; : false, publicPath: config.dev.assetsPublicPath, proxy: config.dev.proxyTable, quiet: true, // necessary for FriendlyErrorsPlugin watchOptions: &#123; poll: config.dev.poll, &#125; &#125;, // 配置webpack插件 plugins: [ // new webpack.DefinePlugin(&#123; 'process.env': require('../config/dev.env') &#125;), new webpack.HotModuleReplacementPlugin(), // 热更新 new webpack.NamedModulesPlugin(), // HMR shows correct file names in console on update. new webpack.NoEmitOnErrorsPlugin(), // https://github.com/ampedandwired/html-webpack-plugin new HtmlWebpackPlugin(&#123; // 后页面中的报错不会阻塞，但是会在编译结束后报错 filename: 'index.html', template: 'index.html', inject: true &#125;), ]&#125;)module.exports = new Promise((resolve, reject) =&gt; &#123; portfinder.basePort = process.env.PORT || config.dev.port portfinder.getPort((err, port) =&gt; &#123; if (err) &#123; reject(err) &#125; else &#123; // publish the new Port, necessary for e2e tests process.env.PORT = port // add port to devServer config devWebpackConfig.devServer.port = port // Add FriendlyErrorsPlugin devWebpackConfig.plugins.push(new FriendlyErrorsPlugin(&#123; compilationSuccessInfo: &#123; messages: [`Your application is running here: http://$&#123;devWebpackConfig.devServer.host&#125;:$&#123;port&#125;`], &#125;, onErrors: config.dev.notifyOnErrors ? utils.createNotifierCallback() : undefined &#125;)) resolve(devWebpackConfig) &#125; &#125;)&#125;) webpack.base.conf.js从webpack.dev.conf.js代码中看到，使用的webpack配置来自webpack.base.conf.js文件，所以先分析webpack.base.conf.js，这个文件主要完成以下这些事情： 配置webpack编译入口 配置webpack输出路径和命名规则 配置模块resolve规则 配置不同类型模块的处理规则 代码注释： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104'use strict'const path = require('path')const utils = require('./utils')const config = require('../config')const vueLoaderConfig = require('./vue-loader.conf')// 给出正确的绝对路径function resolve (dir) &#123; return path.join(__dirname, '..', dir)&#125;const createLintingRule = () =&gt; (&#123; test: /\.(js|vue)$/, loader: 'eslint-loader', enforce: 'pre', include: [resolve('src'), resolve('test')], options: &#123; formatter: require('eslint-friendly-formatter'), emitWarning: !config.dev.showEslintErrorsInOverlay &#125;&#125;)module.exports = &#123; context: path.resolve(__dirname, '../'), // 配置webpack编译入口 entry: &#123; app: './src/main.js' &#125;, // 配置webpack输出路径和命名规则 output: &#123; path: config.build.assetsRoot, // webpack输出的目标文件夹路径 filename: '[name].js', // webpack输出bundle文件命名格式 // webpack编译输出的发布路径 publicPath: process.env.NODE_ENV === 'production' ? config.build.assetsPublicPath : config.dev.assetsPublicPath &#125;, // 配置模块resolve的规则 resolve: &#123; extensions: ['.js', '.vue', '.json'], // 自动resolve的扩展名 // 创建路径别名 alias: &#123; 'vue$': 'vue/dist/vue.esm.js', '@': resolve('src'), &#125; &#125;, // 配置不同类型模块的处理规则 module: &#123; rules: [ ...(config.dev.useEslint ? [createLintingRule()] : []), // 对所有.vue文件使用vue-loader &#123; test: /\.vue$/, loader: 'vue-loader', options: vueLoaderConfig &#125;, // 对src和test文件夹下的.js文件使用babel-loader &#123; test: /\.js$/, loader: 'babel-loader', include: [resolve('src'), resolve('test')] &#125;, // 对图片资源文件使用url-loader，options.name指明了输出的命名规则 &#123; test: /\.(png|jpe?g|gif|svg)(\?.*)?$/, loader: 'url-loader', options: &#123; limit: 10000, name: utils.assetsPath('img/[name].[hash:7].[ext]') &#125; &#125;, // 对音频资源文件使用url-loader，options.name指明了输出的命名规则 &#123; test: /\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$/, loader: 'url-loader', options: &#123; limit: 10000, name: utils.assetsPath('media/[name].[hash:7].[ext]') &#125; &#125;, // 对字体资源文件使用url-loader，options.name指明了输出的命名规则 &#123; test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/, loader: 'url-loader', options: &#123; limit: 10000, name: utils.assetsPath('fonts/[name].[hash:7].[ext]') &#125; &#125; ] &#125;, node: &#123; // prevent webpack from injecting useless setImmediate polyfill because Vue // source contains it (although only uses it if it's native). setImmediate: false, // prevent webpack from injecting mocks to Node native modules // that does not make sense for the client dgram: 'empty', fs: 'empty', net: 'empty', tls: 'empty', child_process: 'empty' &#125;&#125; utils.js和vue-loader.conf.js从上面的代码可以看出使用了utils.js和vue-loader.conf.js这两个文件，utils.js主要完成以下三件事： 配置静态资源路径 生成cssLoader用于加载.vue文件中的样式 生成styleLoaders用于加载不在.vue文件中的单独存在的样式文件 代码注释： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104'use strict'const path = require('path')const config = require('../config')const ExtractTextPlugin = require('extract-text-webpack-plugin')const packageConfig = require('../package.json')exports.assetsPath = function (_path) &#123; const assetsSubDirectory = process.env.NODE_ENV === 'production' ? config.build.assetsSubDirectory : config.dev.assetsSubDirectory return path.posix.join(assetsSubDirectory, _path)&#125;exports.cssLoaders = function (options) &#123; options = options || &#123;&#125; const cssLoader = &#123; loader: 'css-loader', options: &#123; sourceMap: options.sourceMap &#125; &#125; const postcssLoader = &#123; loader: 'postcss-loader', options: &#123; sourceMap: options.sourceMap &#125; &#125; // generate loader string to be used with extract text plugin // 生成与提取文本插件一起使用的加载器字符串 function generateLoaders (loader, loaderOptions) &#123; const loaders = options.usePostCSS ? [cssLoader, postcssLoader] : [cssLoader] if (loader) &#123; loaders.push(&#123; loader: loader + '-loader', options: Object.assign(&#123;&#125;, loaderOptions, &#123; sourceMap: options.sourceMap &#125;) &#125;) &#125; // Extract CSS when that option is specified // (which is the case during production build) // 在指定该选项时提取CSS if (options.extract) &#123; return ExtractTextPlugin.extract(&#123; use: loaders, fallback: 'vue-style-loader' &#125;) &#125; else &#123; return ['vue-style-loader'].concat(loaders) &#125; &#125; // https://vue-loader.vuejs.org/en/configurations/extract-css.html return &#123; css: generateLoaders(), postcss: generateLoaders(), less: generateLoaders('less'), sass: generateLoaders('sass', &#123; indentedSyntax: true &#125;), scss: generateLoaders('sass'), stylus: generateLoaders('stylus'), styl: generateLoaders('stylus') &#125;&#125;// Generate loaders for standalone style files (outside of .vue)//为独立样式文件生成装载器（.vue之外）exports.styleLoaders = function (options) &#123; const output = [] const loaders = exports.cssLoaders(options) for (const extension in loaders) &#123; const loader = loaders[extension] output.push(&#123; test: new RegExp('\\.' + extension + '$'), use: loader &#125;) &#125; return output&#125;exports.createNotifierCallback = () =&gt; &#123; const notifier = require('node-notifier') return (severity, errors) =&gt; &#123; if (severity !== 'error') return const error = errors[0] const filename = error.file &amp;&amp; error.file.split('!').pop() notifier.notify(&#123; title: packageConfig.name, message: severity + ': ' + error.name, subtitle: filename || '', icon: path.join(__dirname, 'logo.png') &#125;) &#125;&#125; vue-loader.js只配置了css加载器以及配置资源路径。 代码注释： 123456789101112131415161718192021222324'use strict'const utils = require('./utils')const config = require('../config')const isProduction = process.env.NODE_ENV === 'production'const sourceMapEnabled = isProduction ? config.build.productionSourceMap : config.dev.cssSourceMapmodule.exports = &#123; // css加载器 loaders: utils.cssLoaders(&#123; sourceMap: sourceMapEnabled, extract: isProduction &#125;), cssSourceMap: sourceMapEnabled, // 源码 cacheBusting: config.dev.cacheBusting, // 缓存 // 配置资源路径 transformToRequire: &#123; video: ['src', 'poster'], source: 'src', img: 'src', image: 'xlink:href' &#125;&#125; build.js开发环境下的配置讲完了，接下来讲构建环境下的配置，构建环境下执行npm run build的时候首先执行的是build.js文件，build.js文件主要做以下几件事： loading动画 删除创建目标文件夹 webpack编译 输出信息 代码注释： 123456789101112131415161718192021222324252627282930313233343536373839404142'use strict'require('./check-versions')() // 检查nodejs和npm版本process.env.NODE_ENV = 'production' // 当前环境为生产环境// 一个可以调用默认软件打开网址、图片、文件等内容的插件，const ora = require('ora')const rm = require('rimraf')const path = require('path')const chalk = require('chalk') // 用于在控制台输出带颜色字体的插件const webpack = require('webpack')const config = require('../config')const webpackConfig = require('./webpack.prod.conf') // 引入生产环境webpack配置const spinner = ora('building for production...')spinner.start() // 开启loading动画rm(path.join(config.build.assetsRoot, config.build.assetsSubDirectory), err =&gt; &#123; // 递归删除旧的目标文件夹 if (err) throw err webpack(webpackConfig, (err, stats) =&gt; &#123; // webpack编译 spinner.stop() // 停止loading动画 if (err) throw err // 没有出错则输出相关信息 process.stdout.write(stats.toString(&#123; colors: true, modules: false, children: false, // if you are using ts-loader, setting this to true will make tyescript errors show up during build chunks: false, chunkModules: false &#125;) + '\n\n') if (stats.hasErrors()) &#123; console.log(chalk.red(' Build failed with errors.\n')) process.exit(1) &#125; console.log(chalk.cyan(' Build complete.\n')) console.log(chalk.yellow( ' Tip: built files are meant to be served over an HTTP server.\n' + ' Opening index.html over file:// won\'t work.\n' )) &#125;)&#125;) webpack.prod.conf.js构建的时候用到的webpack配置来自webpack.prod.conf.js，这个文件主要完成以下几件事： 合并基础的webpack配置 gzip模式下的webpack插件配置 配置webpack插件 代码注释： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150'use strict'const path = require('path')const utils = require('./utils')const webpack = require('webpack')const config = require('../config')const merge = require('webpack-merge')const baseWebpackConfig = require('./webpack.base.conf')const CopyWebpackPlugin = require('copy-webpack-plugin')const HtmlWebpackPlugin = require('html-webpack-plugin')const ExtractTextPlugin = require('extract-text-webpack-plugin') // 用于从webpack生成的bundle中提取文本到特定文件中的插件，可以抽取出css，js文件将其与webpack输出的bundle分离const OptimizeCSSPlugin = require('optimize-css-assets-webpack-plugin')const UglifyJsPlugin = require('uglifyjs-webpack-plugin')const env = process.env.NODE_ENV === 'testing' ? require('../config/test.env') : require('../config/prod.env')// 合并基础的webpack配置const webpackConfig = merge(baseWebpackConfig, &#123; module: &#123; rules: utils.styleLoaders(&#123; sourceMap: config.build.productionSourceMap, extract: true, usePostCSS: true &#125;) &#125;, devtool: config.build.productionSourceMap ? config.build.devtool : false, // 配置webpack的输出 output: &#123; path: config.build.assetsRoot, // 编译输出目录 filename: utils.assetsPath('js/[name].[chunkhash].js'), // 编译输出文件名格式 chunkFilename: utils.assetsPath('js/[id].[chunkhash].js') // 没有指定输出名的文件输出的文件名格式 &#125;,// 配置webpack插件 plugins: [ // http://vuejs.github.io/vue-loader/en/workflow/production.html new webpack.DefinePlugin(&#123; 'process.env': env &#125;), // 丑化压缩代码插件 new UglifyJsPlugin(&#123; uglifyOptions: &#123; compress: &#123; warnings: false &#125; &#125;, sourceMap: config.build.productionSourceMap, parallel: true &#125;), // extract css into its own file 抽离css文件 new ExtractTextPlugin(&#123; filename: utils.assetsPath('css/[name].[contenthash].css'), // Setting the following option to `false` will not extract CSS from codesplit chunks. // Their CSS will instead be inserted dynamically with style-loader when the codesplit chunk has been loaded by webpack. // It's currently set to `true` because we are seeing that sourcemaps are included in the codesplit bundle as well when it's `false`, // increasing file size: https://github.com/vuejs-templates/webpack/issues/1110 allChunks: true, &#125;), // Compress extracted CSS. We are using this plugin so that possible // duplicated CSS from different components can be deduped. new OptimizeCSSPlugin(&#123; cssProcessorOptions: config.build.productionSourceMap ? &#123; safe: true, map: &#123; inline: false &#125; &#125; : &#123; safe: true &#125; &#125;), // generate dist index.html with correct asset hash for caching. // you can customize output by editing /index.html // see https://github.com/ampedandwired/html-webpack-plugin new HtmlWebpackPlugin(&#123; filename: config.build.index, template: 'index.html', inject: true, minify: &#123; removeComments: true, collapseWhitespace: true, removeAttributeQuotes: true // more options: // https://github.com/kangax/html-minifier#options-quick-reference &#125;, // necessary to consistently work with multiple chunks via CommonsChunkPlugin chunksSortMode: 'dependency' &#125;), // keep module.id stable when vender modules does not change new webpack.HashedModuleIdsPlugin(), // enable scope hoisting new webpack.optimize.ModuleConcatenationPlugin(), // split vendor js into its own file new webpack.optimize.CommonsChunkPlugin(&#123; name: 'vendor', minChunks (module) &#123; // any required modules inside node_modules are extracted to vendor return ( module.resource &amp;&amp; /\.js$/.test(module.resource) &amp;&amp; module.resource.indexOf( path.join(__dirname, '../node_modules') ) === 0 ) &#125; &#125;), // extract webpack runtime and module manifest to its own file in order to // prevent vendor hash from being updated whenever app bundle is updated new webpack.optimize.CommonsChunkPlugin(&#123; name: 'manifest', minChunks: Infinity &#125;), // This instance extracts shared chunks from code splitted chunks and bundles them // in a separate chunk, similar to the vendor chunk // see: https://webpack.js.org/plugins/commons-chunk-plugin/#extra-async-commons-chunk new webpack.optimize.CommonsChunkPlugin(&#123; name: 'app', async: 'vendor-async', children: true, minChunks: 3 &#125;), // copy custom static assets new CopyWebpackPlugin([ &#123; from: path.resolve(__dirname, '../static'), to: config.build.assetsSubDirectory, ignore: ['.*'] &#125; ]) ]&#125;)// gzip模式下需要引入compression插件进行压缩if (config.build.productionGzip) &#123; const CompressionWebpackPlugin = require('compression-webpack-plugin') webpackConfig.plugins.push( new CompressionWebpackPlugin(&#123; asset: '[path].gz[query]', algorithm: 'gzip', test: new RegExp( '\\.(' + config.build.productionGzipExtensions.join('|') + ')$' ), threshold: 10240, minRatio: 0.8 &#125;) )&#125;if (config.build.bundleAnalyzerReport) &#123; const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin webpackConfig.plugins.push(new BundleAnalyzerPlugin())&#125;module.exports = webpackConfig check-versions.js从build.js文件可以看出引用了check-versions.js，从名字可以看出这个文件大概做的事情就是确认npm和node版本。 代码注释： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253'use strict'const chalk = require('chalk') // 用于在控制台输出带颜色字体的插件const semver = require('semver') // 语义化版本检查插件const packageConfig = require('../package.json') // 引入package.jsonconst shell = require('shelljs') // 执行Unix命令行的插件// 开辟子进程执行指令cmd并返回结果function exec (cmd) &#123; return require('child_process').execSync(cmd).toString().trim()&#125;// node和npm版本需求const versionRequirements = [ &#123; name: 'node', currentVersion: semver.clean(process.version), versionRequirement: packageConfig.engines.node &#125;]if (shell.which('npm')) &#123; versionRequirements.push(&#123; name: 'npm', currentVersion: exec('npm --version'), versionRequirement: packageConfig.engines.npm &#125;)&#125;module.exports = function () &#123; const warnings = []// 依次判断版本是否符合要求 for (let i = 0; i &lt; versionRequirements.length; i++) &#123; const mod = versionRequirements[i] if (!semver.satisfies(mod.currentVersion, mod.versionRequirement)) &#123; warnings.push(mod.name + ': ' + chalk.red(mod.currentVersion) + ' should be ' + chalk.green(mod.versionRequirement) ) &#125; &#125;// 如果有警告则将其输出到控制台 if (warnings.length) &#123; console.log('') console.log(chalk.yellow('To use this template, you must update following to modules:')) console.log() for (let i = 0; i &lt; warnings.length; i++) &#123; const warning = warnings[i] console.log(' ' + warning) &#125; console.log() process.exit(1) &#125;&#125; webpack.test.conf.js这个文件是单元测试环境的webpack配置文件,该配置是在webpack.base.conf.js的基础上做进一步完善。 代码注释： 1234567891011121314151617181920212223242526'use strict'const utils = require('./utils')const webpack = require('webpack')const merge = require('webpack-merge')const baseWebpackConfig = require('./webpack.base.conf')// 合并基础的webpack配置const webpackConfig = merge(baseWebpackConfig, &#123; devtool: '#inline-source-map', resolveLoader: &#123; alias: &#123; 'scss-loader': 'sass-loader' &#125; &#125;, // 配置webpack插件 plugins: [ new webpack.DefinePlugin(&#123; 'process.env': require('../config/test.env') &#125;) ]&#125;)// no need for app entry during testsdelete webpackConfig.entrymodule.exports = webpackConfig config文件夹分析index.jsconfig文件夹下最主要的文件是index.js，在这里面描述了三种环境下的配置，分别为开发、构建和测试。 代码注释： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283'use strict'// Template version: 1.2.7// see http://vuejs-templates.github.io/webpack for documentation.const path = require('path')module.exports = &#123; // 开发过程中使用的配置 dev: &#123; // Paths assetsSubDirectory: 'static', // webpack编译输出的二级文件夹 assetsPublicPath: '/', // webpack编译输出的发布路径 proxyTable: &#123;&#125;,// 请求代理表，在这里可以配置特定的请求代理到对应的API接口，例如将'/api/xxx'代理到'www.example.com/api/xxx' // Various Dev Server settings // 各种开发服务器设置 host: 'localhost', // can be overwritten by process.env.HOST port: 8080, // can be overwritten by process.env.PORT, if port is in use, a free one will be determined autoOpenBrowser: false, // 启动dev-server之后不自动打开浏览器 errorOverlay: true, notifyOnErrors: true, poll: false, // https://webpack.js.org/configuration/dev-server/#devserver-watchoptions- // Use Eslint Loader? // If true, your code will be linted during bundling and // linting errors and warnings will be shown in the console. useEslint: true, // If true, eslint errors and warnings will also be shown in the error overlay // in the browser. showEslintErrorsInOverlay: false, /** * Source Maps */ // https://webpack.js.org/configuration/devtool/#development devtool: 'eval-source-map', // If you have problems debugging vue-files in devtools, // set this to false - it *may* help // https://vue-loader.vuejs.org/en/options.html#cachebusting cacheBusting: true, // CSS Sourcemaps off by default because relative paths are "buggy" // with this option, according to the CSS-Loader README // (https://github.com/webpack/css-loader#sourcemaps) // In our experience, they generally work as expected, // just be aware of this issue when enabling this option. cssSourceMap: false, &#125;,// 构建产品时使用的配置 build: &#123; // Template for index.html index: path.resolve(__dirname, '../dist/index.html'), // 编译输入的index.html文件 // Paths assetsRoot: path.resolve(__dirname, '../dist'), // webpack输出的目标文件夹路径 assetsSubDirectory: 'static', // webpack编译输出的二级文件夹 assetsPublicPath: '/', // webpack编译输出的发布路径 /** * Source Maps */ productionSourceMap: true, // https://webpack.js.org/configuration/devtool/#production devtool: '#source-map', // Gzip off by default as many popular static hosts such as // Surge or Netlify already gzip all static assets for you. // Before setting to `true`, make sure to: // npm install --save-dev compression-webpack-plugin productionGzip: false, productionGzipExtensions: ['js', 'css'], // gzip模式下需要压缩的文件的扩展名 // Run the build command with an extra argument to // View the bundle analyzer report after build finishes: // `npm run build --report` // Set to `true` or `false` to always turn it on or off bundleAnalyzerReport: process.env.npm_config_report &#125;&#125; dev.env.js、prod.env.js和test.env.js这三个文件分别设置了开发环境、构建环境以及测试环境的环境变量 dev.env.js12345678// 设置了开发环境的环境变量'use strict'const merge = require('webpack-merge')const prodEnv = require('./prod.env')module.exports = merge(prodEnv, &#123; NODE_ENV: '"development"'&#125;) prod.env.js12345// 设置了生产环境的环境变量'use strict'module.exports = &#123; NODE_ENV: '"production"'&#125; test.env.js12345678// 设置了测试环境的环境变量'use strict'const merge = require('webpack-merge')const devEnv = require('./dev.env')module.exports = merge(devEnv, &#123; NODE_ENV: '"testing"'&#125;) 结语webpack没有想的这么难也没想的这么简单。坊间流传webpack不难，难的是配置。可以把官网文档看一遍然后跟着指南敲一遍，去体会这个打包流程的奥妙，大概能学到些什么。webpack中文文档]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《恶意》读后感]]></title>
    <url>%2F2017%2F12%2F25%2Feyi%2F</url>
    <content type="text"><![CDATA[“也没有什么特别的原因，就是看他不爽！” 《恶意》中的野野口修，只是出于根本说不清道不明、不知从何而起却无法终止的恶意，精心设计了一场谋杀。更让人可怕的，不是他所杀害的是一直帮助自己的好朋友日高邦彦，而是他穷尽最后的岁月也要玷污日高的整个人生。甚至，杀害他都只不过是一个开始步骤。 日高和野野口从小学就是形影不离，直到高中开始疏远，当他们再次相遇时日高已经是一个小有成就的作家而野野口仍然籍籍无名，虽一心想成为作家但这条路走的并不顺畅。在日高的帮助下，野野口修成为了一位专门写儿童读物的作家。 但是野野口却杀了如恩人一般的日高，作案动机不明。 野野口把日高塑造成一个伪善的变态的形象。他将野野口的作品占为己有还借此成为畅销书作家，他还拍下野野口想要刺杀自己的录像，收藏好留有野野口指纹的凶器，野野口与日高的前妻初美产生了一个暧昧的关系，这一切都成为日高要挟野野口成为日高的影子作家的条件。 加之身患绝症时日不多，野野口成为了让人同情的杀手，觉得日高的死是咎由自取。但是在加贺警官的坚持不懈下，真相一点一点地浮出水面。 这一切都是阴谋，没有婚外情，没有代笔，没有威胁。这只是野野口精心策划的阴谋，这样的费尽心思，昭示着结束日高的生命只是一个开始，野野口真正想要的是谋杀他的一生。拍好录像带，藏好刀具，收好初美的照片，抄好日高写过的每一本书，他用了整整一年的时间，以一个创作者的想象力和营造力，缓慢而又孜孜不倦地进行着剧情的设计和完善。他甚至提前毒死了日高隔壁邻居的猫，只为了让大家相信，日高本就是一个视生命如草芥，残忍暴戾的人。 日高已经死去，但这却无法消磨野野口在黑暗肆虐生长的恶意。 “即使赌上自己所剩无几的人生，也要贬低对方的人格，这是怎样一种心态啊？” 看似很难理解，但是联系起校园暴力好像又能理解了。记得看过一期《今日说法》一群问题少年少女肆意地对弱小的同龄人施暴，问及为什么要这么做的时候他们的回答大同小异“没什么，就是看他们不爽啊”。看似很任性的话却让人毛骨悚然不寒而栗。 但从人物关系看日高简直是野野口的救世主。他们住在一个街区，上了同一所小学和初中，野野口因为校园暴力不想上学，是日高天天找他结伴去上学。日高为人谦和乐于助人而且有正义感敢于直面校园暴力而野野口胆小、内向，为了逃避被暴力主动去做了恶人的跟班还参与欺负日高的行动。即便如此日高在成为畅销书作家后仍然想着提携野野口，甚至在得到野野口参与校园暴力的证据后还帮助他隐瞒事实。可惜，恨意却早已深植，圣经说，人生下来就带有原罪，即七宗罪，“嫉妒”就是之一。大概野野口的作案动机来自嫉妒吧。 为什么日高能成为畅销书作家而不是我？ 为什么他握着关系我名誉的证据？ 为什么。。 不甘与嫉妒让他的心理最终变得畸形，恨意疯狂地生长就像野野口体内的癌细胞一样，最终让他失去了自己。 无法想象说不清道不明的恶意可以这么可怕。其实，生活中的我们可能更甚于此。毫无来由地讨厌一个热，也许仅仅是一句话一个动作甚至是气味又或许他什么也没有做但就是讨厌他。上天从来没有赋予我们判断一个人的权利，上天也没有给予我们任何优于其他人的特质。虽然我们总是在标榜着人人平等，可是现实中我们却没有做到，我们冷漠的眼神，小小掩鼻的动作，不经意的话，无不透露着内心微小的恶意。 愿这种无来由的恶意越来越少。]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>东野圭吾</tag>
        <tag>恶意</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从自动化测试到持续集成]]></title>
    <url>%2F2017%2F12%2F20%2Fjenkins%2F</url>
    <content type="text"><![CDATA[背景简单直接点，这篇文章就是写如何将自动化测试跟持续集成挂钩起来，怎么将单元测试在jenkins上跑起来。 持续集成整个过程大概是这样： developer在本地工作，将本地工作push到代码仓库（可以是github公有仓库也可以是bitbucket私有仓库），然后会触发CI服务器（CI即持续集成服务器，CI服务器有很多，这里以jenkins做例子。）事先写好的脚本，脚本可以完成编译、单元测试等工作。最后如果代码没有问题则部署到开发环境。 过程准备 在本地安装好jenkins并顺利跑起来 有jenkins账号 创建jenkins项目 新建一个pipeline风格的项目，名称为unit-test Jenkins Job的基本配置 pipeline script写的是需要执行的脚本，git branch是指要拉取的测试分支，credentialsId指拉取代码时需要的密钥，url指存放代码的仓库地址。 点击pipeline syntax进入添加插件的页面 如何配置在jenkins生成测试覆盖率报告进入添加插件页面后，选择publish HTML reports插件 填写单元测试覆盖率报告路径和jenkins生成测试报告存放路径，点击代码段生成器按钮生成代码 将代码生成器生成的代码粘贴到pipeline script 123456789101112131415161718192021222324pipeline &#123; agent &#123; label 'slave0' &#125; stages &#123; stage('prepare') &#123; steps &#123; git branch: '需要测试的分支', credentialsId: '用于拉取代码的密钥', url: 'ssh://代码仓库地址' &#125; &#125; stage('build') &#123; steps &#123; sh 'cnpm install' sh 'npm run test' // 执行单元测试 publishHTML (target: [ allowMissing: false, alwaysLinkToLastBuild: false, keepAll: true, reportDir: 'test/unit/coverage/lcov-report', // 项目单元测试覆盖率报告存放路径 reportFiles: 'index.html', // 项目单元测试覆盖率报告文件 reportName: "RCov Report" // 在jenkins生成的测试报告 ]) &#125; &#125; &#125;&#125; 执行pipeline脚本保存后点击立即构建开始执行pipeline脚本。若是pipeline脚本有变动则需点立即构建，如果只是测试代码有变动则点Replay即可。 不管构建成不成功都会有一个日志Logs。若成功点开可查看测试结果，若失败可以查看失败原因然后调整再次进行构建。 查看测试报告构建成功后会生成测试报告，点击RCov Report查看单元测试覆盖率。 最后写了这么多，又是自动化测试又是持续集成什么的看似很高大上，但是做完这些也仅仅是入门而已，没错就是入门。离真正做到自动化还远着呢。私以为，搭环境这些都不难，难的是如何把单元测试用例写好，如何坚持下去。]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
        <tag>持续集成</tag>
        <tag>自动化测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回顾2017]]></title>
    <url>%2F2017%2F12%2F14%2Fnewyears%2F</url>
    <content type="text"><![CDATA[2017年快结束了，觉得今年特别值得写一写。 关于工作工作有3个月了，这期间学到了很多也认识了很多人。离开象牙塔步入社会让我知道自己有很多不足之处，需要学习的东西特别多。这几个月迷茫的时候沮丧的时候特别多，好在身边的人都没有放弃自己，千言万语说不出，希望自己2018年可以做的更好。 关于生死明天和意外你不知道哪一个先来。从前只是觉得这是一句很鸡汤的话而已，但是外婆的去世让我渐渐理解这句话。回乡下参加葬礼，很多繁冗的规矩让我觉得反感，逝者已逝哪里知道这些，后面看了蔡澜先生的书才理解，生者是想用这种方式让逝者永远活着，活在我们的脑海里，坚信逝者是有灵魂能看得到我们在用这种方式缅怀他们。就像我时常恍惚爷爷并没有走，脑子里有他鲜活的模样，这次轮到外婆也活在了我的脑海里。珍惜当下，活得开心。 关于2018这几个月的经历让我回首望去觉得我这大学虚度了，当初在学校信誓旦旦地说我不会怀念在学校的日子，现在我反悔了，我很怀念，让我再回到大一，我决不会过得浑浑噩噩，学习前端也不会只停留在表面，要把基础学扎实，很多很多想法，但回不去了，我们只能往前走。 2018，定个小目标： 好好完成毕业设计，开开心心毕业，给大学生涯画个圆满的句号 努力成为一名合格的前端人，好好赚钱 培养一个兴趣，比如射箭比如游泳比如书法 多陪家人 多去看看世界，2018年一定要去趟越南]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>2017</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《老了依然可以谈未来》读后感]]></title>
    <url>%2F2017%2F12%2F14%2Fcailan%2F</url>
    <content type="text"><![CDATA[蔡澜老先生是一位非常值得敬佩的人。 读蔡澜先生的书不多，这是第一本，还有好几本躺在书单里，很喜欢他丰富的生活阅历，喜欢他热爱生活热爱美食开心快乐的样子，希望自己也能慢慢向他靠拢，多些乐少些愁。 读《老了依然可以谈未来》我有这些感悟： 人活一世不过数十载，要开心不要忧愁 学到老活到老。多学一些就更自信一些 要保持年轻 年轻时候吃的苦都不算吃苦，这是一种阅历，总会苦尽甘来 要学会花钱，挣了钱拿出10%去尽情花肯定很开心，挣了钱拿去跟朋友家人吃吃喝喝也很开心 多旅行，看看世界各地的人是怎样去生活 要培养一些除了工作之外的兴趣，这样人活着才有趣 小学喜欢动画，初中偏爱看名著，高中喜欢看杂志和轻阅读，大学热爱网络。读书使人精神丰富使人常思考，读书是个好东西，所以工作的我又捡起了这个好习惯。 下一本看张纯如的《南京大屠杀》，本来是很不敢看这类书，但是最近南京大屠杀纪念日让焦点又聚集到这里，我想我们年轻一代需要了解更多的历史真相。]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>蔡澜</tag>
        <tag>读后感</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vuelidate表单验证插件]]></title>
    <url>%2F2017%2F12%2F12%2Fvuelidate%2F</url>
    <content type="text"><![CDATA[VuelidateVuelidate是一款简单轻量级的基于模块的Vue.js验证插件。当前最新的版本是0.6.1,详情可以戳链接看官方文档（https://monterail.github.io/vuelidate/）或者前往github（https://github.com/monterail/vuelidate）。接触Vuelidate源于工作的需求，当时需要做表单验证然后师傅甩给我一个链接让我去学习。学习以后发现这是真的好用，它有以下功能特征： 基于模型 脱离模型 依赖自由，简约的库 支持收集验证 支持嵌套模型 上下文验证 自定义验证，便于使用 支持功能组合 验证了不同数据源：Vuex getter，计算值，等等。 在接触Vuelidate之前还用过另一个表单验证插件veelidate(http://vee-validate.logaretm.com/index.html#)用法跟Vuelidate差不多，但是Vuelidate更深得我心。 安装安装很简单，用npm来安装只需要一句话： 1npm install vuelidate --save 使用main.js在main.js中导入库并用作Vue插件，以便在包含验证配置的所有组件上全局启用该功能： 123import Vue from &apos;vue&apos;import Vuelidate from &apos;vuelidate&apos;Vue.use(Vuelidate) ExampleJS123456789101112131415import &#123; required, maxLength &#125; from &apos;vuelidate/lib/validators&apos;export default &#123; data () &#123; return &#123; username: &apos;&apos; &#125; &#125;, validations: &#123; username: &#123; required, minLength: minLength(6) &#125; &#125;&#125; HTML 内置验证规则 required: 需要非空数据。检查仅包含空格的空数组和字符串。 maxLength:要求输入具有最大指定长度（包括最大值）。适用于数组。 minLength:要求输入具有最小指定长度（包括最小值）。适用于数组。 email: 接受有效的电子邮件地址。请记住，您仍然需要在服务器上进行仔细验证，因为无法发送验证电子邮件地址是否是真实的。 between: 检查数字或日期是否在指定范围内。最小值和最大值都包括在内。 ipAddress: 接受点分十进制表示形式的有效IPv4地址，如127.0.0.1。 alpha: 只接受字母字符。 alphaNum: 只接受字母数字。 numeric: 只接受数字。 sameAs: 检查给定属性是否相等。 url: 只接受网址。 or: 当至少有一个提供的验证器通过时通过。 and: 所有提供的验证器都通过时通过。 requiredIf: 仅当提供的属性或谓词为真时才需要非空数据。 requiredUnless: 仅当提供的属性或谓词为假时才需要非空数据。 minValue: 要求输入具有指定的最小数值或日期。 maxValue: 要求输入具有指定的最大数值或日期。 自定义验证规则除了使用Vuelidate自带的内置验证规则外还可以使用自定义规则满足需求。只需要再新建一个js文件加入自己的验证规则就可以了。 Example新建一个自定义验证规则name.js代码如图所示，基本可以参照内置验证规则写，要注意路径写正确。 index.js1234567891011121314&apos;use strict&apos;Object.defineProperty(exports, &apos;__esModule&apos;, &#123; value: true&#125;)exports.name = undefinedvar _name = require(&apos;./name&apos;)var _name2 = _interopRequireDefault(_name)function _interopRequireDefault (obj) &#123; return obj &amp;&amp; obj.__esModule ? obj : &#123; default: obj &#125; &#125;exports.name = _name2.default name.js1234567891011&apos;use strict&apos;Object.defineProperty(exports, &apos;__esModule&apos;, &#123; value: true&#125;)var _common = require(&apos;vuelidate/lib/validators/common&apos;)var nameRegex = /^[\w-]+$/exports.default = (0, _common.regex)(&apos;name&apos;, nameRegex) 当这些设置好以后就可以像内置规则那样使用了，这里我是在utils下新建了vuelidate验证规则，所以路径可以这么写。 1import &#123; name &#125; from &apos;utils/vuelidate/lib/validators&apos;]]></content>
      <categories>
        <category>validate</category>
      </categories>
      <tags>
        <tag>validate 表单验证插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RegExp正则表达式基本使用]]></title>
    <url>%2F2017%2F12%2F12%2Fregexp1%2F</url>
    <content type="text"><![CDATA[正则表达式是什么？正则表达式是用于匹配字符串中字符组合的模式。在 JavaScript中，正则表达式也是对象。这些模式被用于 RegExp 的 exec 和 test 方法, 以及 String 的 match、replace、search 和 split 方法。本章介绍JavaScript的正则表达式（因为目前我只学过JavaScript的正则表达式呀）。 可以做什么？检验格式比如判断某字符串是否全部由数字组成 12345/^\d+$/.test(&apos;12345&apos;);// true/^\d+$/.test(&apos;12345abc&apos;);// false 内容替换比如将字符串中的数字替换成$号 12&apos;abcd1234&apos;.replace(/\d/g,&apos;$&apos;);// &quot;abcd$$$$&quot; 提取内容字符串的 match 方法可以将匹配到的字符串片段复制到数据中并返回 12&apos;abcd1234&apos;.match(&apos;cd12&apos;);// [&quot;cd12&quot;, index: 2, input: &quot;abcd1234&quot;] 确定位置用下面两种方法可以获得被匹配字符串片段的起始和终止位置。 123456var regexp = /&lt;span&gt;.*?&lt;\/span&gt;/g;regexp.exec(&apos;aabb&apos;);// [&quot;&lt;span&gt;aa&lt;/span&gt;&quot;, index: 5, input: &quot;aabb&quot;](从1数起，第一个span结尾&gt;的位置)&apos;aabb&apos;.search(regexp);// 5(从0数起，第一个span的&lt;的位置) 分割字符串一般的字符串分割都是基于固定的分隔符，但是在某些场景下需要用正则做更复杂的处理， 比如用空格来分割字符串，如果有两个连续的空格出来的结果可能不是我们期待的， 这时就要用正则来处理。 12&apos;a b c&apos;.split(&apos; &apos;);// [&quot;a&quot;, &quot;&quot;, &quot;&quot;, &quot;b&quot;, &quot;c&quot;] 怎么玩？创建正则两种方式，一种是使用一个正则表达式字面量，其由包含在斜杠之间的模式组成 12const regex = /ab+c/;const regex = /^[a-zA-Z]+[0-9]*\W?_$/gi; 另一种是调用RegExp对象的构造函数 12let regex = new RegExp(&quot;ab+c&quot;);let regex = new RegExp(/^[a-zA-Z]+[0-9]*\W?_$/, &quot;gi&quot;); 参数 g :全局匹配;找到所有匹配，而不是在第一个匹配后停止 i :忽略大小写 m :多行; 将开始和结束字符（^和$）视为在多行上工作（也就是，分别匹配每一行的开始和结束（由 \n 或 \r 分割），而不只是只匹配整个输入字符串的最开始和最末尾处。 u :Unicode; 将模式视为Unicode序列点的序列 y :粘性匹配; 仅匹配目标字符串中此正则表达式的lastIndex属性指示的索引(并且不尝试从任何后续的索引匹配)。 特殊字符特殊字符有很多，其含义和用法可以参考MDN文档 RegExp对象方法这里想讲test、match、exec和replace这四种方法，因为这几种非常常见和常用也是我学习正则时遇到的难点。 用法 说明 返回值 pattern.test(str) 判断str是否包含匹配结果 包含返回true，不包含返回false。 pattern.exec(str) 根据pattern对str进行正则匹配 返回匹配结果数组,如匹配不到返回null str.match(pattern) 根据pattern对str进行正则匹配 返回匹配结果数组,如匹配不到返回null str.replace(pattern, replacement) 根据pattern进行正则匹配,把匹配结果替换为replacement 一个新的字符串 test()字符串的test方法，比较常用在判断语句中，用于检测一个字符串是否匹配某个模式： 1RegExpObject.test(string) 例：如果字符串 string 中含有与 RegExpObject 匹配的文本，则返回 true，否则返回 false： 12/\d/.test(&apos;asdf2&apos;)// true （字符串中含有数字所以返回true） match()match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。 非全局匹配 例： 123var a = &apos;abcd&apos;.match(/\w/);console.log(a);// [&quot;a&quot;, index: 0, input: &quot;abcd&quot;] （只匹配第一个就停止了） 全局匹配 例： 123var a = &apos;abcd&apos;.match(/\w/g);console.log(a);// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;] （匹配全部才停止） exec()exec()方法用于比较复杂的模式匹配或者是说你为你提供更多的信息： 1RegExpObject.exec(string) 如果在string中找到了匹配的文本，则返回一个包含这些文本的数组，否侧返回null。 返回的数组的第一个元素是与整个正则匹配的文本，然后数组的第二个元素是与整个正则的第一个子表达式(分组)相匹配的文本，数组的第三个元素整个正则的第二个子表达式(分组)相匹配的文本，以此类推。例： 123var result = /(\d+)-(\w+)/.exec(&apos;12-ab&apos;);console.log(result);// [&quot;12-ab&quot;, &quot;12&quot;, &quot;ab&quot;, index: 0, input: &quot;12-ab&quot;] 从上面返回的数组结果可知，数组添加了两个额外的属性，分别是：index, input index: 匹配文本的第一个字符的位置。 input: 指输入的整体的文本。 例： 1234console.log(result.index)// 0console.log(result.input)// 12-ab ​ 执行exec函数时，尽管是全局匹配的正则表达式，但是exec方法只对指定的字符串进行一次匹配， 获取字符串中第一个与正则表达式想匹配的内容，并且将匹配内容和子匹配的结果存储到返回的数组中。 例： 12/\d/g.exec(&apos;aa22&apos;)// [&quot;2&quot;, index: 2, input: &quot;aa22&quot;] （只匹配一个数字就停止了） ​ replace()replace()方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。这个方法接收两个必须的参数： pattern: 这个参数可以是字符串或是RegExp对象。 replacement： 替换匹配项的字符串或处理函数的返回值 返回结果： 当未找到匹配项的时候，返回原始字符串。 例： 12&apos;aaaa&apos;.replace(&apos;bbb&apos;, &apos;b&apos;)// &quot;aaaa&quot; 当pattern为字符串或者为非全局的RegExp对象的时候，只替换找到的第一项匹配项。 例： 12&apos;aaaa&apos;.replace(&apos;a&apos;, &apos;b&apos;)// &quot;baaa&quot; 当pattern为全局的RegExp对象的时候，替换每一项匹配项。 例： 12&apos;aaaa&apos;.replace(/\w/g, &apos;b&apos;)// &quot;bbbb&quot; replacement为函数时，函数的返回值将作为替换字符串;函数的第一个参数的值是每一个匹配项,当然还有第二个参数，它的值是每个匹配项在原始字符串的中位置，从0开始。 例： 1234aaaa&apos;.replace(/\w/g, function() &#123; return &apos;b&apos;;&#125;);// &quot;bbbb&quot; ​ 最后学习正则最重要的就是正则表达式要写对，我比较笨有时候会写很久。这里推荐两个比较有用的好帮手帮助更有效率地学习正则。 http://regex.zjmainstay.cn/（可以在线检测表达式写的是否正确） https://jex.im/regulex/#!flags=&amp;re=%5E(a%7Cb)*%3F%24（可以看到清晰明了的逻辑图）]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>正则基本使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用正则表达式]]></title>
    <url>%2F2017%2F12%2F12%2Fregexp%2F</url>
    <content type="text"><![CDATA[匹配IP地址，比如192.168.1.1 1/((25[0-5]|2[0-4]\d|[01]?\d?\d).)&#123;3&#125;(25[0-5]|2[0-4]\d|[01]?\d?\d)/ 匹配subnet（子网掩码），比如192.168.1.1/22 1/((25[0-5]|2[0-4]\d|[01]?\d?\d).)&#123;3&#125;(25[0-5]|2[0-4]\d|[01]?\d?\d)\/(3[0-2]|[0-2]\d)/ 匹配IP范围，比如192.168.0.1~192.168.0.2 1/((25[0-5]|2[0-4]\d|[01]?\d?\d).)&#123;3&#125;(25[0-5]|2[0-4]\d|[01]?\d?\d)~((25[0-5]|2[0-4]\d|[01]?\d?\d).)&#123;3&#125;(25[0-5]|2[0-4]\d|[01]?\d?\d)/ 比如：192.168.1.1~10 1/((25[0-5]|2[0-4]\d|[01]?\d?\d).)&#123;3&#125;(25[0-5]|2[0-4]\d|[01]?\d?\d)\~(25[0-5]|2[0-4]\d|[01]?\d?\d)/ 匹配：1.http://{IP}/ 2.http://{IP}:端口/ 3.http://{域名}/ 4.http://{域名}：端口/ 比如：1.http://192.168.0.1/ 2.http://192.168.0.1:8080/ 3.http://www.baidu.com/ 4.http://www.baidu.com:8080/ 1/^((http|https|ftp):\/\/)((((25[0-5]|2[0-4]\d|[01]?\d?\d).)&#123;3&#125;(25[0-5]|2[0-4]\d|[01]?\d?\d))|(a-zA-Z0-9&#123;0,62&#125;)((.a-zA-Z0-9&#123;0,62&#125;)+?)?):?([0-9]|[1-9]\d|[1-9]\d&#123;2&#125;|[1-9]\d&#123;3&#125;|[1-5]\d&#123;4&#125;|6[0-4]\d&#123;3&#125;|65[0-4]\d&#123;2&#125;|655[0-2]\d|6553[0-5])?\/$ 匹配端口号，一般0-65535。两种写法都可以，第一种就是把最大的数提到最前面不需要开始和结尾的符号，第二种就是最小的在最前面需要开始和结尾符号不然匹配不到 121./(6553[0-5]|655[0-2]\d|65[0-4]\d&#123;2&#125;|65[0-4]\d&#123;2&#125;|6[0-4]\d&#123;3&#125;|[1-5]\d&#123;4&#125;|[1-9]\d&#123;3&#125;|[1-9]\d&#123;2&#125;|[1-9]\d|[0-9])/2./^([0-9]|[1-9]\d|[1-9]\d&#123;2&#125;|[1-9]\d&#123;3&#125;|[1-5]\d&#123;4&#125;|6[0-4]\d&#123;3&#125;|65[0-4]\d&#123;2&#125;|655[0-2]\d|6553[0-5])$/ 匹配ASCII字符串，只匹配ASCII字符，ASCII字符包括什么自行google 1/[\x00-\xff]+/g 匹配字母/数字/下划线/短横线/中文 1/^([\w-]+|[\u4e00-\u9fa5]+)$/ 匹配数字字母下划线及短横线 1/[\w-]+/ 单个数字 1/[0-9]/或/\d/ 多个数字 1/[0-9]/或/[0-9]+/或/\d+/或/\d/]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu下安装Xmind]]></title>
    <url>%2F2017%2F12%2F12%2Fxmind%2F</url>
    <content type="text"><![CDATA[为什么要选择Xmind因为我需要一款思维导图软件，之前有个手机APP就叫思维导图觉得还可以，搜了一下并没有PC版然后搜到了xmind，感觉linux系统的电脑应用软件不是很多啊（或许是我见识短）anyway~我决定装xmind。 我为什么要写出来选就选了呗用就用了呗写什么写啊，老子喜欢写就写你管我。哎呀其实是第一次装的时候踩坑了没装成功于是这次我决定写出来。 安装首先先去官网http://www.xmind.net/download/linux/ 把安装包下载下来。 一般来说点击这个红色按钮download就可以了，我第一次也是这么做的，然而并没有成功至于为什么没成功具体原因我也不记得了，大概是有些依赖没装什么的吧。这次我学乖了，把页面拉到底部 点击Previous Versions按钮跳转到另一个页面 我是linux系统64位，当然选第四个啦，下载下来是一个deb包，运行以下代码即可安装成功~惊不惊喜意不意外！ $ sudo dpkg -i xmind-7.5-update1-linux_amd64.deb 成功了当然要上图晒一下啦，有模板也有空白的随便选 By the wayXmind现在有个测试版本叫Xmind ZAN,感觉界面很炫酷啊，可以去官网申请测试资格，很伤心测试版本没有Linux版本!!!!宝宝不开心，只有Windows和Mac。但是还是放一些图满足一下吧]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>xmind</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web工程师的前端书单]]></title>
    <url>%2F2017%2F12%2F12%2Fweb%2F</url>
    <content type="text"><![CDATA[JavaScript入门 《JavaScript权威指南（第六版）》 《JavaScript高级程序设计》 《JavaScript DOM编程艺术》 《ECMAScript6入门》 进阶 《编写可维护的JavaScript》 《JavaScript异步编程》 《JAVASCRIPT语言精髓与编程实践》 《高性能JavaScript》 《You Don’t Know JS》 CSS进阶 《CSS权威指南（第三版）》 《精通CSS（第2版）》 网络协议&amp;架构 《HTTP权威指南》 《Web性能权威指南》 《大型网站技术架构》 NodeJS入门 《Node.js开发指南》 进阶 《深入浅出Node.js》 用户体验&amp;产品 《点石成金》 《结网@改变世界的互联网产品经理》]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将本地项目上传到github]]></title>
    <url>%2F2017%2F12%2F10%2Fgithub1%2F</url>
    <content type="text"><![CDATA[本地创建一个项目比如我本地新建了一个项目，名为myBlog 建立本地仓库初始化进入myBlog文件夹执行 1git init 初始化项目成功后文件夹下会新增.git隐藏文件夹 添加到仓库执行指令 1git add . 将项目添加到版本库 生成commit执行指令 1git commit -m &quot;myblog&quot; 关联github仓库在github新建一个仓库 添加github远程仓库地址 执行指令 1git remote add origin https://github.com/Evey-huang/myBlog.git 上传本地代码1git push -u origin master Fix Bug在上传代码的时候出了点错误提示“Pushing to Git returning Error Code 403 fatal: HTTP request failed” 解决办法是修改.git/config文件 执行指令 1vim .git/config 将 修改为 再次执行 1git push -u origin master 即可上传成功，去github就可以看到提交记录啦~]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端单元测试初探]]></title>
    <url>%2F2017%2F12%2F08%2Funit%2F</url>
    <content type="text"><![CDATA[什么是单元测试来自维基百科的回答 单元测试（英语：Unit Testing）又称为模块测试, 是针对程序的最小单元来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。一个单元可能是单个程序、函数、过程、方法等。 需不需要写单测好的单元测试是使你开发的产品走向成功的秘密武器： 有助于设计：写单元测试首先给了你一个如何设计 API 的清晰视角。 特性文档：单元测试描述和记录了代码所要实现的所有需求。 检查开发者需求理解程度：是否开发者足够理解问题，在测试代码里描述了所有的关键需求点？ QA（质量保证）：依靠人工 QA 容易出错。 有助于持续交付：自动化的 QA 能够自动防止将有缺陷的产品构建并发布上线。 通俗地讲单测可以提高代码质量以及大幅减少bug的存在 如何开始既然已经确定了单测的必要性，那么如何开始进行单测呢？ 单测工具链框架目前比较火的测试框架就是jasmine和mocha，这里我选用mocha。 什么是MochaMocha 是一个功能丰富的javascript测试框架，可以运行在nodejs和浏览器环境，使异步测试变得简单有趣。mocha 串联运行测试，允许灵活和精确地报告结果，同时映射未捕获的异常用来纠正测试用例。 特点 简单 灵活 有趣 安装1npm install -g mocha 断言库目前比较流行的断言库主要有以下几个： chai：BDD/TDD 双模 ，同时支持 should / expect / assert 三种风格的断言库强大插件机制。 shouldjs：BDD风格断言库，由TJ Holowaychuk 发起。 expectjs：追求极简的 BDD 风格断言库，基于 should.js 简化。 assert：风格最保守，node 的核心模块，node 环境可以直接使用。 这里我使用的是Chai，因为mocha+chai是黄金搭档呀 安装1npm install -g chai Mock库什么是Mock编写测试的时候，可能需要和系统内的某个模块或系统外某个实体交互，例如数据库读写、邮件发送等。这时就需要使用 mock 技术来模拟。 有哪些Mock库sinon.js：只用过这个，其他不大清楚。sinon允许你把代码中难以被测试的部分替换为更容易测试的内容。 安装1npm install sinon 测试集成工具karma：Google Angular 团队写的，功能很强大，有很多插件 安装1npm install karma --save-dev 搭建环境基于vue-cli脚手架生成的项目模板中可以自动添加测试环境，但是这不利于刚接触单测的同学去学习，以下是我从零开始搭建测试环境的经过。 新建项目参考另一篇文章新建Vue项目也可以了解新建vue项目的步骤。 安装脚手架1npm install vue-cli -g 创建项目创建一个名为unit-test的项目 1vue init webpack unit-test 然后会有询问 这里在询问需不需要加入unit单测的时候选了no是因为本文主要是讲怎样从0开始搭建测试环境，所以创建项目的时候先不考虑加入。 进入项目1cd unit-test 启动项目1npm run dev 项目正常运行的话可以开始搭建测试环境 测试环境搭建项目整体结构1234567891011121314151617181920212223242526├── unit-test/ │—— build //构建脚本目录 | |—— webpack.base.conf.js // wabpack基础配置 | |—— webpack.prod.conf.js // wabpack生产环境配置 | |—— webpack.test.conf.js // webpack测试环境配置 | |—— webpack.dev.conf.js // wabpack开发环境配置 | |—— vue-loader.conf.js | |—— utils.js // 构建相关工具方法 | |—— config // 项目配置 | |—— dev.env.js // 开发环境变量 | |—— prod.env.js // 生产环境变量 | |—— test.env.js // 测试环境变量 | |—— index.js // 项目配置文件 |—— src // 源码目录 | |—— components | |—— HelloWorld.vue |—— test | |—— unit | |—— coverage //自动生成覆盖文件夹 | |—— index.js //测试文件入口 | |—— karma.conf.js // karma配置文件 | |—— .eslintrc //支持断言书写 | |—— specs //测试用例文件夹 | |—— HelloWorld.spec.js |—— package.json // npm包配置文件，定义了项目的npm脚本，依赖包等信息 安装karma1npm install karma --save-dev 进入unit文件夹1cd test/unit/ 初始化karma1karma init 这样就生成了一个基本的配置文件karma.conf.js 相关文件配置karma.conf.js 123456789101112131415161718192021222324var webpackConfig = require('../../build/webpack.test.conf')module.exports = function (config) &#123; config.set(&#123; browsers: ['PhantomJS'], // 浏览器 frameworks: ['mocha', 'sinon-chai', 'phantomjs-shim'], // 测试框架 reporters: ['spec', 'coverage'], // 测试报告 files: ['./index.js'], // 测试入口文件 preprocessors: &#123; './index.js': ['webpack', 'coverage'] // 处理测试文件 &#125;, webpack: webpackConfig, // webpack配置 webpackMiddleware: &#123; noInfo: true // 不显示webpack打包日志信息 &#125;, coverageReporter: &#123; // 代码覆盖率报告 dir: './coverage', reporters: [ &#123; type: 'lcov', subdir: '.' &#125;, &#123; type: 'text-summary' &#125; ] &#125; &#125;)&#125; webpack.test.conf.js 12345678910111213141516171819202122232425262728const utils = require('./utils')const webpack = require('webpack') // 指定环境需要引入webpackconst merge = require('webpack-merge')const baseWebpackConfig = require('./webpack.base.conf')const webpackConfig = merge(baseWebpackConfig, &#123; module: &#123; rules: utils.styleLoaders() &#125;, devtool: '#inline-source-map', resolveLoader: &#123; alias: &#123; 'scss-loader': 'sass-loader' &#125; &#125;, // 指定环境 plugins: [ new webpack.DefinePlugin(&#123; 'process.env': require('../config/test.env') &#125;) ]&#125;)// no need for app entry during testsdelete webpackConfig.entrymodule.exports = webpackConfig webpack.prod.conf.js 在webpack.prod.conf.js中引用test.env 123const env = process.env.NODE_ENV === 'testing' ? require('../config/test.env') : require('../config/prod.env') test.env.js 1234567'use strict'const merge = require('webpack-merge')const devEnv = require('./dev.env')module.exports = merge(devEnv, &#123; NODE_ENV: '"testing"'&#125;) index.js 123456789import Vue from 'vue'Vue.config.productionTip = falseconst testsContext = require.context('./specs', true, /\.spec$/)testsContext.keys().forEach(testsContext)const srcContext = require.context('../../src', true, /^\.\/(?!main(\.js)?$)/)srcContext.keys().forEach(srcContext) .eclintrc.js 123456789&#123; "env": &#123; "mocha": true &#125;, "globals": &#123; "expect": true, "sinon": true &#125;&#125; package.json 1234567891011121314151617181920"scripts": &#123; "unit": "cross-env BABEL_ENV=test karma start test/unit/karma.conf.js --single-run", "test": "npm run unit"&#125;"devDependencies": &#123; "chai": "^4.1.2", "cross-env": "^5.0.1", "karma": "^1.7.1", "karma-mocha": "^1.3.0", "karma-coverage": "^1.1.1", "karma-phantomjs-launcher": "^1.0.4", "karma-phantomjs-shim": "^1.4.0", "karma-sinon-chai": "^1.3.1", "karma-sourcemap-loader": "^0.3.7", "karma-spec-reporter": "0.0.31", "karma-webpack": "^2.0.2", "mocha": "^3.2.0", "sinon": "^4.0.0", "sinon-chai": "^2.8.0"&#125; 安装依赖1npm install 测试用例官网vue单元测试有介绍测试用例怎么写，下面是一个简单的测试用例： 简单测试用例HelloWorld.spec.js 1234567891011121314151617import Vue from 'vue'import HelloWorld from '@/components/HelloWorld'describe('HelloWorld.vue', () =&gt; &#123; it('should render correct contents', () =&gt; &#123; const Constructor = Vue.extend(HelloWorld) const vm = new Constructor().$mount() expect(vm.$el.querySelector('.hello h1').textContent) .to.equal('Welcome to Your Vue.js App') &#125;) it('should be Essential Links', () =&gt; &#123; const Constructor = Vue.extend(HelloWorld) const vm = new Constructor().$mount() expect(vm.$el.querySelector('.hello h2').textContent) .to.equal('Essential Links') &#125;)&#125;) 运行测试用例1npm run test 生成测试报告 测试报告分析从图中我们可以看到它有四个指标： Statements: 语句覆盖率，执行到每个语句； Branches：分支覆盖率，执行到每个if代码块； Functions：函数覆盖率，调用到程序中的每一个函数； Lines：行覆盖率，执行到程序中的每一行。 从图中我们也可以看出覆盖率极低，打开coverage文件夹可以看到: 123456789101112coverage/├── lcov-report│ ├── base.css│ ├── index.html│ ├── prettify.css│ ├── prettify.js│ ├── sort-arrow-sprite.png│ ├── sorter.js│ └── unit│ ├── index.html // 测试覆盖率报告│ └── index.js.html // 覆盖率低的原因└── lcov.info 打开index.js.html可以看到覆盖率低的原因 从图中可以看到红色部分是测试用例没有覆盖到的地方，旁边的1x表示执行了一次。因为本文所写的测试用例HelloWorld.spec.js很简单没有涉及到逻辑，没有覆盖到这些函数很正常。对于实际开发来说，通过这个清晰的报告，我们可以在代码中看出那些函数，那些代码块没有被执行，从而去分析原因，修正测试用例，完善代码逻辑，提高质量。 打开lcov.info文件可以看到(这里我截取了部分)： 12345678910111213141516FN:50,getDefaultFN:51,getModuleExportsFN:57,(anonymous_7)FN:68,(anonymous_8)....FNF:694FNH:207....FNDA:0,simpleNormalizeChildrenFNDA:0,normalizeChildrenFNDA:0,isTextNodeFNDA:0,normalizeArrayChildren.....DA:633,2DA:635,1DA:638,1 FN: 代表函数,50 51 57 68这些行分布对应源代码中的函数开始的行号 FNF:694: 代表一共有694个函数 FNH:207: 代表其中207个函数被测试所覆盖 FNDA:0,isTextNode: 代表了isTextNode这个函数被执行了0次 DA: 代表当前被执行到的次数 … 还有很多解析想要了解可以google 再谈单测完成以上步骤我觉得我懂单元测试了（可是单元测试不懂我，泪眼朦胧.jpg），但是翻过一座山又遇一条河，这条河让我觉得我又不懂单元测试了： 在实际项目中单元测试到底测的是什么？ 确定了该测什么之后应该怎么去写测试用例？ 单元测试到底测的是什么就我的认知来看，这些需要测： 和安全相关的代码逻辑 核心的功能模块，函数 短期不会发生变化的 UI 组件 提供外部调用的接口 怎么去写测试用例真的说不好怎样去写测试用例，很多资料只是告诉你怎么写一个简单的测试用例然后跑起来，但怎样去写一个好的测试用例却不知道。目前我经验少也总结不出什么有用的建议，以后再填坑吧。 什么才是一个好的测试失败报告 你测试的是什么？ 它是做什么的？ 它实际输出了什么？（实际行为） 它本该输出什么？（预期行为） 最后本文的代码戳这里单元测试代码]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>单元测试</tag>
        <tag>karma</tag>
        <tag>mocha</tag>
        <tag>chai</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一个单元测试]]></title>
    <url>%2F2017%2F12%2F06%2Funit-test%2F</url>
    <content type="text"><![CDATA[一开始让我学单元测试我是拒绝的，但是无奈师傅交给的任务。看了一早上的测试文章云里雾里差点睡着，下午就决定自己先来动手实践一下单元测试，到底单元测试是什么怎么写结果是怎样。 开始创建项目使用vue-cli先创建一个vuejs项目，这里就不累赘了，另一篇文章《新建Vue项目》有写。 注意！npm install安装依赖的时候要有耐心(其实是我网速慢)千万不要随便停止，因为那可能会漏装了东西导致后面会出BUG。我就是心急导致后面测试运行失败，只好默默地把node_modules删了再重新运行npm install 安装好依赖，接下来我们执行下面的命令，这个命令将会在本地运行你的应用并在浏览器中打开。 1npm run dev 在项目中，可以找到下面这些目录：build、config、node_modules、src、static 和 test。对于本教程来说最重要的是src，它包括我们应用的代码，用来测试。 第一次测试我们将从创建简单的列表组件开始。在 src/components 里创建一个新文件叫做 list.vue 并且将下面代码写进去。 list.vue 123456789101112131415161718192021&lt;template&gt; &lt;div&gt; &lt;h1&gt;My To Do List&lt;/h1&gt; &lt;br&gt; &lt;!-- displays list --&gt; &lt;ul&gt; &lt;li v-for=&quot;item in listItems&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;list&apos;, data () &#123; return &#123; listItems: [&apos;buy food&apos;, &apos;play games&apos;, &apos;sleep&apos;] &#125; &#125;&#125;&lt;/script&gt; 在这个组件中，列表项被储存在数组（listItems）里面。数据被传递到模板，然后被遍历v-for，最后展现在页面上。 我们需要看到刚刚创建的列表，所以我们创建一个新的路由来展示这个组件。在src/router/index.js中创建一个路由，添加完了代码应该是下面这样的： 123456789101112131415161718192021import Vue from &apos;vue&apos;import Router from &apos;vue-router&apos;import HelloWorld from &apos;@/components/HelloWorld&apos;import List from &apos;@/components/list&apos;Vue.use(Router)export default new Router(&#123; routes: [ &#123; path: &apos;/&apos;, name: &apos;HelloWorld&apos;, component: HelloWorld &#125;, &#123; path: &apos;/to-do&apos;, name: &apos;ToDo&apos;, component: List &#125; ]&#125;) 现在，访问localhost:8080/#/to-do，可以看到我们做的页面。 首先，我们要测试的是数据的正确性。在test/unit/specs目录下创建一个list.spec.js，并且写入下面的代码： 12345678910111213141516// 在这个文件中我们describing了list.vue组件，并且创建了一个空的测试，// 它将要检查这个组件的列表展示，这是一个基本的Mocha测试文件import Vue from &apos;vue&apos;import List from &apos;@/components/list&apos;describe(&apos;list.vue&apos;, () =&gt; &#123; it(&apos;display items from the list&apos;, () =&gt; &#123; // our test goes here // build component 我们继承了Vue组件并安装了这个组件 const Constructor = Vue.extend(List) const ListComponent = new Constructor().$mount() // 下面是第一个断言，我们使用Chai断言提供的&apos;expect&apos;模式还有&apos;should&apos;和&apos;assert&apos;模式。这个断言用来检查HTML列表中的文本是否和组件的data里的数据列表吻合。 expect(ListComponent.$el.textContent).to.contain(&apos;play game&apos;) // 可以使用ListComponent.$el来获取组件的HTML，用ListComponent.$el.textContent获取HTML内的内容 &#125;)&#125;) 最后就是使用npm run unit来运行cross-env BABEL_ENV=test karma start test/unit/karma.conf.js --single-run。 我就是被卡在了这里，运行npm run unit出现错误 综合github和stack overflow的回答，想了想问题可能出现在依赖安装上，我没有等它自己安装完就停止了，后来又用cnpm安装但是应该没装全，所以我把node_modules卸载了重装，现在还在装网速简直慢到不行 保持这个进度已经很久了，简直崩溃。 最后建议网络慢的使用cnpm装，我用cnpm装快得飞起。 如果测试都通过了，将会有一个绿色的列表来显示测试报告，让你了解测试都覆盖了哪些代码。 模拟用户输入上一步做了一个简单的功能，只能展示数据并不能做交互，下一步要做的就是做简单的交互往to-do list中添加新项目。 创建一个Input框来输入内容，一个button用来提交内容。 list.vue 1234567891011121314151617181920212223242526272829303132&lt;!--使用v-model，输入框里面的内容将和newItem进行双向绑定。当按钮被点击后执行addItemToList，将newItem添加到to-do list数组里，并且清空newItem里面的内容，新的项目将会被添加到列表中--&gt;&lt;template&gt; &lt;div&gt; &lt;h1&gt;My To Do List&lt;/h1&gt; &lt;br&gt; &lt;!-- displays list --&gt; &lt;input type=&quot;text&quot; v-model=&quot;newItem&quot;&gt; &lt;button @click=&quot;addItemToList&quot;&gt;Add&lt;/button&gt; &lt;ul&gt; &lt;li v-for=&quot;item in listItems&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;test&apos;, data () &#123; return &#123; listItems: [&apos;buy food&apos;, &apos;play games&apos;, &apos;sleep&apos;], newItem: &apos;&apos; &#125; &#125;, methods: &#123; addItemToList () &#123; this.listItems.push(this.newItem) this.newItem = &apos;&apos; // 清空newItem里面的内容 &#125; &#125;&#125;&lt;/script&gt; 然后更新测试文件 list.spec.js 12345678910111213141516171819202122232425import Vue from &apos;vue&apos;import List from &apos;@/components/list&apos;describe(&apos;list.vue&apos;, () =&gt; &#123; it(&apos;add a new item to list on click&apos;, () =&gt; &#123; // build component 我们继承了Vue组件并安装了这个组件 const Constructor = Vue.extend(List) const ListComponent = new Constructor().$mount() // set value of new item 给newItem设置内容 ListComponent.newItem = &apos;brush my teeth&apos; // find button querySelector可以像选择真的元素一样选择这个按钮。 const button = ListComponent.$el.querySelector(&apos;button&apos;) // simulate click event 模拟点击事件 const clickEvent = new window.Event(&apos;click&apos;) button.dispatchEvent(clickEvent) ListComponent._watcher.run() // assert list contains new item 检查断言列表包含新项目 expect(ListComponent.$el.textContent).to.contain(&apos;brush my teeth&apos;) expect(ListComponent.listItems).to.contain(&apos;brush my teeth&apos;) &#125;)&#125;) 运行这个测试文件npm run unit 一个完整的成功的单元测试就完成啦~]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>单元测试</tag>
        <tag>unit test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[征服梧桐山]]></title>
    <url>%2F2017%2F12%2F04%2FNg-Tung-Shan%2F</url>
    <content type="text"><![CDATA[出发7点多起床8点出门然后在老街集合，一起去吃了早餐，吃完去找了很久的公交站在差点找到的时候决定打车去，老街过去也不算远，这次去的是正门，没拍照人太多所以就不PO照了。如果想去后门的话可以从黄贝岭站坐公交去，比较近。大概十一点左右大部队全部集合完毕准备上山。 路线1：老街出发坐公交车（这次去没有坐公交，目测2-5块）/打车60左右–正门 路线2：黄贝岭出发坐公交/打车–后门 上山从泰山涧走山路上的山，没有选择走大路，山路比较难走但是风景也比较好看，一路上都有小溪，走到最高处的时候如果水多还可以看到瀑布。从泰山涧一直爬，爬到山顶跟大路交汇的地方然后顺着大路走到好汉坡就可以看到上大梧桐的山路了。大梧桐海拔最高，有900多米，所以一致决定征服最高峰。在下午四点钟左右登顶，欣赏一下美景。 尽量穿运动鞋，和舒适的衣服。这样没有这么累，看到一个小哥穿人字拖爬山我也是被惊到了。 能戴帽子最好，可以遮阳挡风。不然这么多护肤品白瞎了。 最好背双肩包，我背的挎包爬到抖的地方老是跑到前面来挡住视线，很影响发挥。 上山大概3-4个钟，走的快的话2个可能就OK了。 下山四点钟左右登顶然后休息，四点多五点开始下山，七点左右才走到山脚下。真的肠子都悔青了好吗！！！快走到山脚才想起来走后门更近，简直想哭死在路上。下山真的很可怕好吗，天又黑又没指示牌，一直走一直走不知道什么时候才能到山脚，要不是我凭着一股意志力真的要瘫在路上回不来了。 登山棍还是很有必要的，特别是下山的时候！ 零食适量就好，我们带了好多后面又是背回来了。 早点上山！早点上山！早点上山！重要的事情说三遍，我们快中午了才开始爬以至于下山的时候都7点天黑了，而且梧桐山没有路灯，死不死。 量力而行！量力而行！量力而行！重要的事情说三遍！就是死要登顶下山的时候腿痛得不行抖得不行，现在废了一样。 少喝水，梧桐山厕所巨少！巨少！巨少！ 总结近期不想做几件事：爬山、吃周黑鸭、吃烧烤（我有预感我要打脸，不过还是要立flag）]]></content>
      <categories>
        <category>玩</category>
      </categories>
      <tags>
        <tag>登山</tag>
        <tag>梧桐山</tag>
        <tag>深圳最高山</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新建Vue项目]]></title>
    <url>%2F2017%2F12%2F04%2Fvue-start%2F</url>
    <content type="text"><![CDATA[在新建vue项目之前应该先检查一下是否已经安装好npm、node 新建一个vue项目 设置镜像 1npm install -g cnpm --registry=https://registry.npm.taobao.org 安装webpack 1npm install webpack -g 安装vue-cli 1npm install vue-cli -g 创建项目 1vue init webpack-simple 项目名称 进入项目所在目录，安装依赖 1npm install 启动项目 1npm run dev 在创建项目初始化的时候（也就是第四步）遇到了问题。 问题：vue-cli · Failed to download repo vuejs-templates/webpack-simple: tunneling socket could not be established, cause=connect ECONNREFUSED 127.0.0.1:80 解决：删除无效代理 定位问题的过程： 本机ping外网发现正常，说明本机网络OK 本机尝试安装其他的包，发现进度条不动；其他机器尝试安装一样的包，发现能安装成功，证明包本身没问题 经过上面两步确定不是网络问题不是包问题而是本机有问题，然后npm config查看本机配置与其他机器配置有什么不一样，发现本机比其他机器多了无效代理 删除无效代理。vim /usr/local/etc/npmc找到设置代理的语句然后删除 启动后的界面]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue 教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu下安装Typora]]></title>
    <url>%2F2017%2F11%2F30%2FTypora%2F</url>
    <content type="text"><![CDATA[简介MarkdownMarkdown 是一种轻量级的「标记语言」，它用简洁的语法代替排版，而不像一般我们用的字处理软件 Word 或 Pages 有大量的排版、字体设置。它使我们专心于码字，用「标记」语法，来代替常见的排版格式。例如此文从内容到格式，甚至插图，键盘就可以通通搞定了，减少了鼠标的点击。目前来看，支持 Markdown 语法的编辑器有很多，但他们的交互形式基本都是将「编辑」和「预览」分离开来的，要么是直接左右排列编辑和预览窗口，要么是要在两种模式之间来回切换，以前刚接触的时候常常被搞晕。后面电脑换了Linux系统以后觉得编辑文件没有这么方便于是就想下个编辑器来用，找了很久觉得Typora这个编辑器很简洁大方深得小仙女的心于是立马下载来用。 TyporaTypora(https://typora.io/)不同于以往的markdown编辑器在于它只使用一个窗口，却能优雅地实现同时将代码编辑与预览「一体化」结合起来，从而为用户带来更加流畅直观的「所见即所得的 Markdown 写作体验」。Typora 即时显示 Markdown 语法格式的能力被官方称之为 WYSIWYG （What You See Is What You Get）。虽然一开始用觉得有点麻烦甚至想弃坑，但是用久了习惯了就会发现很好用很方便。正式开始用Typora还是在接触gitbook以后，想要写文章才想起来原来我有个markdown编辑器，于是就开造啦~ 安装在Ubuntu下安装Typora按照下列命令依次输入即可成功安装Typora，很幸运没有出现BUG最讨厌的就是BUG了。 安装成功以后找到Typora图标双击打开就可以用了，当然如果你很熟悉命令行模式那你也可以在命令行进行启动。 1234$ sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAE$ sudo add-apt-repository &apos;deb https://typora.io linux/&apos;$ sudo apt-get update$ sudo apt-get install typora 用法markdown啦当然用的markdown格式写咯]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Typora</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
</search>
